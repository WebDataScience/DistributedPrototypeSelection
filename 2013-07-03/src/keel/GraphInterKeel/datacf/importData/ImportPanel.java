/***********************************************************************

	This file is part of KEEL-software, the Data Mining tool for regression, 
	classification, clustering, pattern mining and so on.

	Copyright (C) 2004-2010
	
	F. Herrera (herrera@decsai.ugr.es)
    L. Sánchez (luciano@uniovi.es)
    J. Alcalá-Fdez (jalcala@decsai.ugr.es)
    S. García (sglopez@ujaen.es)
    A. Fernández (alberto.fernandez@ujaen.es)
    J. Luengo (julianlm@decsai.ugr.es)

	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program.  If not, see http://www.gnu.org/licenses/
  
**********************************************************************/

package keel.GraphInterKeel.datacf.importData;

import java.util.logging.Level;
import java.util.logging.Logger;
import keel.GraphInterKeel.datacf.util.FileUtils;
import keel.GraphInterKeel.datacf.util.OptionsDialog;
import keel.GraphInterKeel.datacf.util.KeelFileFilter;
import keel.GraphInterKeel.util.Path;
import java.awt.CardLayout;
import java.awt.Cursor;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.DataInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.DefaultListModel;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JList;
import javax.swing.JOptionPane;
import javax.swing.JTextArea;
import keel.Algorithms.Preprocess.Converter.CsvToKeel;
import keel.Algorithms.Preprocess.Converter.DbToKeel;
import keel.Algorithms.Preprocess.Converter.DifToKeel;
import keel.Algorithms.Preprocess.Converter.ExcelToKeel;
import keel.Algorithms.Preprocess.Converter.HtmlToKeel;
import keel.Algorithms.Preprocess.Converter.PrnToKeel;
import keel.Algorithms.Preprocess.Converter.PropertyListToKeel;
import keel.Algorithms.Preprocess.Converter.TxtToKeel;
import keel.Algorithms.Preprocess.Converter.UciToKeel;
import keel.Algorithms.Preprocess.Converter.WekaToKeel;
import keel.Algorithms.Preprocess.Converter.XmlToKeel;
import keel.Dataset.Attribute;
import keel.Dataset.Attributes;
import keel.Dataset.InstanceSet;
import keel.GraphInterKeel.datacf.DataCFFrame;
import keel.GraphInterKeel.experiments.Files;
import org.jdom.Document;
import org.jdom.Element;
import org.jdom.JDOMException;
import org.jdom.input.SAXBuilder;
import org.jdom.output.Format;
import org.jdom.output.XMLOutputter;

/**
 * <p>
 * @author Written by Pedro Antonio Guti�rrez and Juan Carlos Fern�ndez (University of C�rdoba) 23/10/2008
 * @version 1.0
 * @since JDK1.5
 * </p>
 */
public class ImportPanel extends javax.swing.JPanel {

    /**
     * <p>
     * Panel for importing datasets
     * </p>
     */

    private boolean isUnsupervised;

    /**
     * <p>
     * Constructor that initializes the panel
     * </p>
     */
    public ImportPanel() {
        initComponents();
    }

    /**
     * <p>
     * This method is called from within the constructor to
     * initialize the form.
     * </p>
     * <p>
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     * </p>
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        importSelectPanel = new javax.swing.JPanel();
        importSelectMainPanel = new javax.swing.JPanel();
        nextSelectPartitionsButton = new javax.swing.JButton();
        nextSelectDatasetButton = new javax.swing.JButton();
        datasetIcon = new javax.swing.JLabel();
        partitionsIcon = new javax.swing.JLabel();
        importSeparator = new javax.swing.JSeparator();
        importDatasetLabel = new javax.swing.JLabel();
        importPartitionsLabel = new javax.swing.JLabel();
        importBrowserPanel = new javax.swing.JPanel();
        buttonPanel = new javax.swing.JPanel();
        optionsButton = new javax.swing.JButton();
        outputFormatLabel = new javax.swing.JLabel();
        outputFormatComboBox = new javax.swing.JComboBox();
        processHeaderCheckBox = new javax.swing.JCheckBox();
        backBrowserButton = new javax.swing.JButton();
        nextBrowserButton = new javax.swing.JButton();
        fileBrowserPanel = new keel.GraphInterKeel.datacf.util.FileBrowserPanel();
        KeelFileFilter fileFilter = new KeelFileFilter();
        fileFilter.addExtension("csv");
        fileFilter.setFilterName("CSV Files (.csv)");
        fileBrowserPanel.getFileChooser().addChoosableFileFilter(fileFilter);
        importPreviewPanel = new javax.swing.JPanel();
        mainPanel = new javax.swing.JPanel();
        leftPreviewPanel = new javax.swing.JPanel();
        originalScrollPanel = new javax.swing.JScrollPane();
        originalTextArea = new javax.swing.JTextArea();
        originalSeparator = new javax.swing.JSeparator();
        originalLabel = new javax.swing.JLabel();
        rightPreviewPanel = new javax.swing.JPanel();
        resultScrollPanel = new javax.swing.JScrollPane();
        resultTextArea = new javax.swing.JTextArea();
        resultSeparator = new javax.swing.JSeparator();
        resultsLabel = new javax.swing.JLabel();
        informationPreviewLabel = new javax.swing.JLabel();
        nextPreviewButton = new javax.swing.JButton();
        backPreviewButton = new javax.swing.JButton();
        importToKeelPanel = new javax.swing.JPanel();
        importToExperimentCheckBox = new javax.swing.JCheckBox();
        userDatasetCheckBox = new javax.swing.JCheckBox();
        realComboBox = new javax.swing.JComboBox();
        partitionComboBox = new javax.swing.JComboBox();
        importPartitionsPanel = new javax.swing.JPanel();
        mainPartitionsPanel = new javax.swing.JPanel();
        nextPartitionsButton = new javax.swing.JButton();
        backPartitionsButton = new javax.swing.JButton();
        trainingPanel = new javax.swing.JPanel();
        trainingScrollPanel = new javax.swing.JScrollPane();
        trainingList = new JList(trainingModel);
        testingPanel = new javax.swing.JPanel();
        testingScrollPanel = new javax.swing.JScrollPane();
        testingList = new JList(testingModel);
        cleanButton = new javax.swing.JButton();
        trainingButtons = new javax.swing.JPanel();
        addTrainingButton = new javax.swing.JButton();
        removeTrainingButton = new javax.swing.JButton();
        testingButtons = new javax.swing.JPanel();
        addTestingButton = new javax.swing.JButton();
        removeTestingButton = new javax.swing.JButton();
        outputFormatPartitionsPanel = new javax.swing.JPanel();
        optionsPartitionsButton = new javax.swing.JButton();
        outputFormatPartitionsComboBox = new javax.swing.JComboBox();
        outputFormatPartitionsLabel = new javax.swing.JLabel();
        processHeaderPartitionsCheckBox = new javax.swing.JCheckBox();
        fileBrowserPanel1 = new keel.GraphInterKeel.datacf.util.FileBrowserPanel();
        fileBrowserPanel1 = new keel.GraphInterKeel.datacf.util.FileBrowserPanel();
        fileFilter = new KeelFileFilter();
        fileFilter.addExtension("csv");
        fileFilter.setFilterName("CSV Files (.csv)");
        fileBrowserPanel1.getFileChooser().addChoosableFileFilter(fileFilter);
        fileBrowserPanel1.getFileChooser().setMultiSelectionEnabled(true);

        setName("Form"); // NOI18N
        setLayout(new java.awt.CardLayout());

        importSelectPanel.setName("importSelectPanel"); // NOI18N
        importSelectPanel.setLayout(new java.awt.GridBagLayout());

        importSelectMainPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Select Import Option"));
        importSelectMainPanel.setName("importSelectMainPanel"); // NOI18N
        importSelectMainPanel.setLayout(new java.awt.GridBagLayout());

        nextSelectPartitionsButton.setText("Next->");
        nextSelectPartitionsButton.setToolTipText("Import Partitions");
        nextSelectPartitionsButton.setMaximumSize(new java.awt.Dimension(100, 100));
        nextSelectPartitionsButton.setMinimumSize(new java.awt.Dimension(88, 30));
        nextSelectPartitionsButton.setName("nextSelectPartitionsButton"); // NOI18N
        nextSelectPartitionsButton.setPreferredSize(new java.awt.Dimension(88, 30));
        nextSelectPartitionsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextSelectPartitionsButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 10, 0);
        importSelectMainPanel.add(nextSelectPartitionsButton, gridBagConstraints);

        nextSelectDatasetButton.setText("Next->");
        nextSelectDatasetButton.setToolTipText("Import Dataset");
        nextSelectDatasetButton.setMaximumSize(new java.awt.Dimension(100, 100));
        nextSelectDatasetButton.setMinimumSize(new java.awt.Dimension(88, 30));
        nextSelectDatasetButton.setName("nextSelectDatasetButton"); // NOI18N
        nextSelectDatasetButton.setPreferredSize(new java.awt.Dimension(88, 30));
        nextSelectDatasetButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextSelectDatasetButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 10, 0);
        importSelectMainPanel.add(nextSelectDatasetButton, gridBagConstraints);

        datasetIcon.setIcon(new javax.swing.ImageIcon(getClass().getResource("/keel/GraphInterKeel/resources/ico/datacf/importDataset.png"))); // NOI18N
        datasetIcon.setName("datasetIcon"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 5, 0, 0);
        importSelectMainPanel.add(datasetIcon, gridBagConstraints);

        partitionsIcon.setIcon(new javax.swing.ImageIcon(getClass().getResource("/keel/GraphInterKeel/resources/ico/datacf/importPartitions.png"))); // NOI18N
        partitionsIcon.setName("partitionsIcon"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(10, 5, 0, 0);
        importSelectMainPanel.add(partitionsIcon, gridBagConstraints);

        importSeparator.setOrientation(javax.swing.SwingConstants.VERTICAL);
        importSeparator.setName("importSeparator"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridheight = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.VERTICAL;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 8, 0);
        importSelectMainPanel.add(importSeparator, gridBagConstraints);

        importDatasetLabel.setText("<html><b>Import Dataset</b><hr>Select this option if you want to import only a single file from other formats to KEEL format.</html>");
        importDatasetLabel.setVerticalAlignment(javax.swing.SwingConstants.TOP);
        importDatasetLabel.setMinimumSize(new java.awt.Dimension(250, 200));
        importDatasetLabel.setName("importDatasetLabel"); // NOI18N
        importDatasetLabel.setPreferredSize(new java.awt.Dimension(250, 200));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.insets = new java.awt.Insets(0, 5, 0, 5);
        importSelectMainPanel.add(importDatasetLabel, gridBagConstraints);

        importPartitionsLabel.setText("<html><b>Import Partitions</b><hr>Select this option if you have previously performed partitions of a dataset in other formats and you want to import them to KEEL format.</html>");
        importPartitionsLabel.setVerticalAlignment(javax.swing.SwingConstants.TOP);
        importPartitionsLabel.setMinimumSize(new java.awt.Dimension(250, 200));
        importPartitionsLabel.setName("importPartitionsLabel"); // NOI18N
        importPartitionsLabel.setPreferredSize(new java.awt.Dimension(250, 200));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.insets = new java.awt.Insets(0, 5, 0, 0);
        importSelectMainPanel.add(importPartitionsLabel, gridBagConstraints);

        importSelectPanel.add(importSelectMainPanel, new java.awt.GridBagConstraints());

        add(importSelectPanel, "Select");

        importBrowserPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Import Dataset"));
        importBrowserPanel.setName("importBrowserPanel"); // NOI18N
        importBrowserPanel.setLayout(new java.awt.GridBagLayout());

        buttonPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Input Format"));
        buttonPanel.setName("buttonPanel"); // NOI18N

        optionsButton.setText("Options");
        optionsButton.setToolTipText("Click to configure the options of this format");
        optionsButton.setName("optionsButton"); // NOI18N
        optionsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                optionsButtonActionPerformed(evt);
            }
        });

        outputFormatLabel.setText("Select Input Format");
        outputFormatLabel.setName("outputFormatLabel"); // NOI18N

        outputFormatComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "CSV to Keel", "TXT to Keel", "PRN to Keel", "C4.5 to Keel", "Excel to Keel", "Dif to Keel", "PropertyList to Keel", "Weka to Keel", "XML to Keel", "HTML Tab to Keel", "Database SQL to Keel", "Keel to Keel" }));
        outputFormatComboBox.setToolTipText("Select Input Format");
        outputFormatComboBox.setName("outputFormatComboBox"); // NOI18N
        importOptionsDialog = new OptionsDialog(parent, true);
        importOptionsDialog.addProperty("Separator",",");
        importOptionsDialog.addProperty("Null Value","");
        outputFormatComboBox.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                outputFormatComboBoxItemStateChanged(evt);
            }
        });

        processHeaderCheckBox.setSelected(true);
        processHeaderCheckBox.setText("Attribute name header");
        processHeaderCheckBox.setToolTipText("Check this if the first row of your data includes the attribute names"); // NOI18N
        processHeaderCheckBox.setName("processHeaderCheckBox"); // NOI18N

        javax.swing.GroupLayout buttonPanelLayout = new javax.swing.GroupLayout(buttonPanel);
        buttonPanel.setLayout(buttonPanelLayout);
        buttonPanelLayout.setHorizontalGroup(
            buttonPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(buttonPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(outputFormatLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(outputFormatComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(optionsButton, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(processHeaderCheckBox)
                .addContainerGap(376, Short.MAX_VALUE))
        );
        buttonPanelLayout.setVerticalGroup(
            buttonPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(buttonPanelLayout.createSequentialGroup()
                .addGroup(buttonPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(outputFormatLabel)
                    .addComponent(outputFormatComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(optionsButton)
                    .addComponent(processHeaderCheckBox))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.weightx = 1.0;
        importBrowserPanel.add(buttonPanel, gridBagConstraints);

        backBrowserButton.setText("<-Back");
        backBrowserButton.setToolTipText("Return to previous window for selecting import option");
        backBrowserButton.setMaximumSize(new java.awt.Dimension(100, 100));
        backBrowserButton.setMinimumSize(new java.awt.Dimension(88, 30));
        backBrowserButton.setName("backBrowserButton"); // NOI18N
        backBrowserButton.setPreferredSize(new java.awt.Dimension(88, 30));
        backBrowserButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                backBrowserButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.ipadx = 10;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 0.5;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 10);
        importBrowserPanel.add(backBrowserButton, gridBagConstraints);

        nextBrowserButton.setText("Next->");
        nextBrowserButton.setToolTipText("Preview imported file");
        nextBrowserButton.setMaximumSize(new java.awt.Dimension(100, 100));
        nextBrowserButton.setMinimumSize(new java.awt.Dimension(88, 30));
        nextBrowserButton.setName("nextBrowserButton"); // NOI18N
        nextBrowserButton.setPreferredSize(new java.awt.Dimension(88, 30));
        nextBrowserButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextBrowserButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.ipadx = 10;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 0.5;
        gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
        importBrowserPanel.add(nextBrowserButton, gridBagConstraints);

        fileBrowserPanel.setName("fileBrowserPanel"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        importBrowserPanel.add(fileBrowserPanel, gridBagConstraints);

        add(importBrowserPanel, "Browser");

        importPreviewPanel.setName("importPreviewPanel"); // NOI18N
        importPreviewPanel.setLayout(new java.awt.GridLayout(1, 0));

        mainPanel.setName("mainPanel"); // NOI18N
        mainPanel.setLayout(new java.awt.GridBagLayout());

        leftPreviewPanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        leftPreviewPanel.setMaximumSize(new java.awt.Dimension(10000000, 10000000));
        leftPreviewPanel.setMinimumSize(new java.awt.Dimension(300, 124));
        leftPreviewPanel.setName("leftPreviewPanel"); // NOI18N

        originalScrollPanel.setName("originalScrollPanel"); // NOI18N

        originalTextArea.setEditable(false);
        originalTextArea.setMaximumSize(new java.awt.Dimension(999999999, 999999999));
        originalTextArea.setMinimumSize(new java.awt.Dimension(260, 260));
        originalTextArea.setName("originalTextArea"); // NOI18N
        originalScrollPanel.setViewportView(originalTextArea);

        originalSeparator.setName("originalSeparator"); // NOI18N

        originalLabel.setText("Original File");
        originalLabel.setName("originalLabel"); // NOI18N

        javax.swing.GroupLayout leftPreviewPanelLayout = new javax.swing.GroupLayout(leftPreviewPanel);
        leftPreviewPanel.setLayout(leftPreviewPanelLayout);
        leftPreviewPanelLayout.setHorizontalGroup(
            leftPreviewPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(leftPreviewPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(leftPreviewPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(leftPreviewPanelLayout.createSequentialGroup()
                        .addComponent(originalScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 412, Short.MAX_VALUE)
                        .addContainerGap())
                    .addComponent(originalSeparator, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 422, Short.MAX_VALUE)
                    .addGroup(leftPreviewPanelLayout.createSequentialGroup()
                        .addComponent(originalLabel)
                        .addContainerGap(367, Short.MAX_VALUE))))
        );
        leftPreviewPanelLayout.setVerticalGroup(
            leftPreviewPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(leftPreviewPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(originalLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(originalSeparator, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(originalScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 377, Short.MAX_VALUE)
                .addContainerGap())
        );

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 0.5;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(10, 0, 0, 0);
        mainPanel.add(leftPreviewPanel, gridBagConstraints);

        rightPreviewPanel.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        rightPreviewPanel.setMaximumSize(new java.awt.Dimension(10000000, 10000000));
        rightPreviewPanel.setMinimumSize(new java.awt.Dimension(300, 124));
        rightPreviewPanel.setName("rightPreviewPanel"); // NOI18N

        resultScrollPanel.setName("resultScrollPanel"); // NOI18N

        resultTextArea.setEditable(false);
        resultTextArea.setMaximumSize(new java.awt.Dimension(999999999, 999999999));
        resultTextArea.setMinimumSize(new java.awt.Dimension(260, 260));
        resultTextArea.setName("resultTextArea"); // NOI18N
        resultScrollPanel.setViewportView(resultTextArea);

        resultSeparator.setName("resultSeparator"); // NOI18N

        resultsLabel.setText("Imported File (KEEL format)");
        resultsLabel.setName("resultsLabel"); // NOI18N

        javax.swing.GroupLayout rightPreviewPanelLayout = new javax.swing.GroupLayout(rightPreviewPanel);
        rightPreviewPanel.setLayout(rightPreviewPanelLayout);
        rightPreviewPanelLayout.setHorizontalGroup(
            rightPreviewPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, rightPreviewPanelLayout.createSequentialGroup()
                .addGroup(rightPreviewPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, rightPreviewPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(resultScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 412, Short.MAX_VALUE))
                    .addComponent(resultSeparator, javax.swing.GroupLayout.DEFAULT_SIZE, 422, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, rightPreviewPanelLayout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(resultsLabel)))
                .addContainerGap())
        );
        rightPreviewPanelLayout.setVerticalGroup(
            rightPreviewPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(rightPreviewPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(resultsLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(resultSeparator, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(resultScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 377, Short.MAX_VALUE)
                .addContainerGap())
        );

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 0.5;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(10, 0, 0, 0);
        mainPanel.add(rightPreviewPanel, gridBagConstraints);

        informationPreviewLabel.setText("This is a previsualization of the result of importing the files you have given");
        informationPreviewLabel.setName("informationPreviewLabel"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.ipadx = 10;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(7, 6, 2, 0);
        mainPanel.add(informationPreviewLabel, gridBagConstraints);

        nextPreviewButton.setText("Save");
        nextPreviewButton.setToolTipText("Save the imported files");
        nextPreviewButton.setMaximumSize(new java.awt.Dimension(100, 100));
        nextPreviewButton.setMinimumSize(new java.awt.Dimension(88, 30));
        nextPreviewButton.setName("nextPreviewButton"); // NOI18N
        nextPreviewButton.setPreferredSize(new java.awt.Dimension(88, 30));
        nextPreviewButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextPreviewButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.ipadx = 10;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 0.5;
        gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
        mainPanel.add(nextPreviewButton, gridBagConstraints);

        backPreviewButton.setText("<-Back");
        backPreviewButton.setToolTipText("Return to select files");
        backPreviewButton.setMaximumSize(new java.awt.Dimension(100, 100));
        backPreviewButton.setMinimumSize(new java.awt.Dimension(88, 30));
        backPreviewButton.setName("backPreviewButton"); // NOI18N
        backPreviewButton.setPreferredSize(new java.awt.Dimension(88, 30));
        backPreviewButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                backPreviewButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.ipadx = 10;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 0.5;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 10);
        mainPanel.add(backPreviewButton, gridBagConstraints);

        importToKeelPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Import to Experiments"));
        importToKeelPanel.setName("importToKeelPanel"); // NOI18N
        importToKeelPanel.setLayout(new java.awt.GridBagLayout());

        importToExperimentCheckBox.setText("Import to the Experiments Section");
        importToExperimentCheckBox.setName("importToExperimentCheckBox"); // NOI18N
        importToExperimentCheckBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                importToExperimentCheckBoxActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 0.3;
        importToKeelPanel.add(importToExperimentCheckBox, gridBagConstraints);

        userDatasetCheckBox.setSelected(true);
        userDatasetCheckBox.setText("User Dataset");
        userDatasetCheckBox.setEnabled(false);
        userDatasetCheckBox.setName("userDatasetCheckBox"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 0.5;
        importToKeelPanel.add(userDatasetCheckBox, gridBagConstraints);

        realComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Real", "Laboratory" }));
        realComboBox.setEnabled(false);
        realComboBox.setName("realComboBox"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        gridBagConstraints.weightx = 0.5;
        importToKeelPanel.add(realComboBox, gridBagConstraints);

        partitionComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "KFold", "5x2" }));
        partitionComboBox.setEnabled(false);
        partitionComboBox.setName("partitionComboBox"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 14);
        importToKeelPanel.add(partitionComboBox, gridBagConstraints);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        mainPanel.add(importToKeelPanel, gridBagConstraints);

        importPreviewPanel.add(mainPanel);

        add(importPreviewPanel, "Preview");

        importPartitionsPanel.setName("importPartitionsPanel"); // NOI18N

        mainPartitionsPanel.setName("mainPartitionsPanel"); // NOI18N
        mainPartitionsPanel.setPreferredSize(new java.awt.Dimension(800, 800));
        mainPartitionsPanel.setLayout(new java.awt.GridBagLayout());

        nextPartitionsButton.setText("Next->");
        nextPartitionsButton.setToolTipText("Preview imported files");
        nextPartitionsButton.setMaximumSize(new java.awt.Dimension(100, 100));
        nextPartitionsButton.setMinimumSize(new java.awt.Dimension(88, 30));
        nextPartitionsButton.setName("nextPartitionsButton"); // NOI18N
        nextPartitionsButton.setPreferredSize(new java.awt.Dimension(88, 30));
        nextPartitionsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                nextPartitionsButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.EAST;
        mainPartitionsPanel.add(nextPartitionsButton, gridBagConstraints);

        backPartitionsButton.setText("<-Back");
        backPartitionsButton.setToolTipText("Return to previous window for selecting import option");
        backPartitionsButton.setMaximumSize(new java.awt.Dimension(100, 100));
        backPartitionsButton.setMinimumSize(new java.awt.Dimension(88, 30));
        backPartitionsButton.setName("backPartitionsButton"); // NOI18N
        backPartitionsButton.setPreferredSize(new java.awt.Dimension(88, 30));
        backPartitionsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                backPartitionsButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        mainPartitionsPanel.add(backPartitionsButton, gridBagConstraints);

        trainingPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Training Files"));
        trainingPanel.setName("trainingPanel"); // NOI18N

        trainingScrollPanel.setName("trainingScrollPanel"); // NOI18N

        trainingList.setName("trainingList"); // NOI18N
        trainingScrollPanel.setViewportView(trainingList);

        javax.swing.GroupLayout trainingPanelLayout = new javax.swing.GroupLayout(trainingPanel);
        trainingPanel.setLayout(trainingPanelLayout);
        trainingPanelLayout.setHorizontalGroup(
            trainingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(trainingPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(trainingScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 191, Short.MAX_VALUE)
                .addContainerGap())
        );
        trainingPanelLayout.setVerticalGroup(
            trainingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(trainingPanelLayout.createSequentialGroup()
                .addComponent(trainingScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 186, Short.MAX_VALUE)
                .addContainerGap())
        );

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 0.2;
        gridBagConstraints.weighty = 0.5;
        mainPartitionsPanel.add(trainingPanel, gridBagConstraints);

        testingPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Test Files"));
        testingPanel.setName("testingPanel"); // NOI18N

        testingScrollPanel.setName("testingScrollPanel"); // NOI18N

        testingList.setName("testingList"); // NOI18N
        testingScrollPanel.setViewportView(testingList);

        javax.swing.GroupLayout testingPanelLayout = new javax.swing.GroupLayout(testingPanel);
        testingPanel.setLayout(testingPanelLayout);
        testingPanelLayout.setHorizontalGroup(
            testingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(testingPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(testingScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 191, Short.MAX_VALUE)
                .addContainerGap())
        );
        testingPanelLayout.setVerticalGroup(
            testingPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(testingPanelLayout.createSequentialGroup()
                .addComponent(testingScrollPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 187, Short.MAX_VALUE)
                .addContainerGap())
        );

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 0.2;
        gridBagConstraints.weighty = 0.5;
        mainPartitionsPanel.add(testingPanel, gridBagConstraints);

        cleanButton.setText("Clean");
        cleanButton.setToolTipText("Clean training and test files");
        cleanButton.setName("cleanButton"); // NOI18N
        cleanButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cleanButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
        mainPartitionsPanel.add(cleanButton, gridBagConstraints);

        trainingButtons.setName("trainingButtons"); // NOI18N
        trainingButtons.setLayout(new java.awt.GridLayout(2, 1));

        addTrainingButton.setText("-->");
        addTrainingButton.setToolTipText("Add selected file to training files");
        addTrainingButton.setName("addTrainingButton"); // NOI18N
        addTrainingButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addTrainingButtonaddButtonActionPerformed(evt);
            }
        });
        trainingButtons.add(addTrainingButton);

        removeTrainingButton.setText("<--");
        removeTrainingButton.setToolTipText("Remove selected file from training files");
        removeTrainingButton.setName("removeTrainingButton"); // NOI18N
        removeTrainingButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeTrainingButtonremoveButtonActionPerformed(evt);
            }
        });
        trainingButtons.add(removeTrainingButton);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 1;
        mainPartitionsPanel.add(trainingButtons, gridBagConstraints);

        testingButtons.setName("testingButtons"); // NOI18N
        testingButtons.setLayout(new java.awt.GridLayout(2, 1));

        addTestingButton.setText("-->");
        addTestingButton.setToolTipText("Add selected file to test files");
        addTestingButton.setName("addTestingButton"); // NOI18N
        addTestingButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addTestingButtonaddButtonActionPerformed(evt);
            }
        });
        testingButtons.add(addTestingButton);

        removeTestingButton.setText("<--");
        removeTestingButton.setToolTipText("Remove selected file from test files");
        removeTestingButton.setName("removeTestingButton"); // NOI18N
        removeTestingButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeTestingButtonremoveButtonActionPerformed(evt);
            }
        });
        testingButtons.add(removeTestingButton);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 2;
        mainPartitionsPanel.add(testingButtons, gridBagConstraints);

        outputFormatPartitionsPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Options"));
        outputFormatPartitionsPanel.setName("outputFormatPartitionsPanel"); // NOI18N

        optionsPartitionsButton.setText("Options");
        optionsPartitionsButton.setToolTipText("Click to configure the options of this format");
        optionsPartitionsButton.setName("optionsPartitionsButton"); // NOI18N
        optionsPartitionsButton.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                optionsPartitionsButtonItemStateChanged(evt);
            }
        });
        optionsPartitionsButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                optionsPartitionsButtonActionPerformed(evt);
            }
        });

        outputFormatPartitionsComboBox.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "CSV to Keel", "TXT to Keel", "PRN to Keel", "C4.5 to Keel", "Excel to Keel", "Dif to Keel", "PropertyList to Keel", "Weka to Keel", "XML to Keel", "HTML Tab to Keel", "Keel to Keel" }));
        outputFormatPartitionsComboBox.setToolTipText("Select Input Format");
        outputFormatPartitionsComboBox.setName("outputFormatPartitionsComboBox"); // NOI18N
        outputFormatPartitionsComboBox.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                outputFormatPartitionsComboBoxItemStateChanged(evt);
            }
        });

        outputFormatPartitionsLabel.setText("Select Input Format");
        outputFormatPartitionsLabel.setName("outputFormatPartitionsLabel"); // NOI18N

        processHeaderPartitionsCheckBox.setSelected(true);
        processHeaderPartitionsCheckBox.setText("Attribute name header");
        processHeaderPartitionsCheckBox.setToolTipText("Check this if the first row of your data includes the attribute names"); // NOI18N
        processHeaderPartitionsCheckBox.setName("processHeaderPartitionsCheckBox"); // NOI18N

        javax.swing.GroupLayout outputFormatPartitionsPanelLayout = new javax.swing.GroupLayout(outputFormatPartitionsPanel);
        outputFormatPartitionsPanel.setLayout(outputFormatPartitionsPanelLayout);
        outputFormatPartitionsPanelLayout.setHorizontalGroup(
            outputFormatPartitionsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(outputFormatPartitionsPanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(outputFormatPartitionsLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(outputFormatPartitionsComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(optionsPartitionsButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(processHeaderPartitionsCheckBox)
                .addContainerGap(140, Short.MAX_VALUE))
        );
        outputFormatPartitionsPanelLayout.setVerticalGroup(
            outputFormatPartitionsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(outputFormatPartitionsPanelLayout.createSequentialGroup()
                .addGroup(outputFormatPartitionsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(outputFormatPartitionsLabel)
                    .addComponent(outputFormatPartitionsComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(optionsPartitionsButton)
                    .addComponent(processHeaderPartitionsCheckBox))
                .addContainerGap(17, Short.MAX_VALUE))
        );

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        mainPartitionsPanel.add(outputFormatPartitionsPanel, gridBagConstraints);

        fileBrowserPanel1.setName("fileBrowserPanel1"); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 2;
        gridBagConstraints.gridheight = 2;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 0.8;
        mainPartitionsPanel.add(fileBrowserPanel1, gridBagConstraints);

        javax.swing.GroupLayout importPartitionsPanelLayout = new javax.swing.GroupLayout(importPartitionsPanel);
        importPartitionsPanel.setLayout(importPartitionsPanelLayout);
        importPartitionsPanelLayout.setHorizontalGroup(
            importPartitionsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(mainPartitionsPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 872, Short.MAX_VALUE)
        );
        importPartitionsPanelLayout.setVerticalGroup(
            importPartitionsPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(mainPartitionsPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 555, Short.MAX_VALUE)
        );

        add(importPartitionsPanel, "Partitions");
    }// </editor-fold>//GEN-END:initComponents

private void nextSelectDatasetButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextSelectDatasetButtonActionPerformed
    lastSelectedPanel = "Select";
    ((CardLayout) this.getLayout()).show(this, "Browser");
    datasets = true;
    cleanPanels();
}//GEN-LAST:event_nextSelectDatasetButtonActionPerformed

private void nextSelectPartitionsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextSelectPartitionsButtonActionPerformed
    lastSelectedPanel = "Select";
    ((CardLayout) this.getLayout()).show(this, "Partitions");
    datasets = false;
    cleanPanels();
}//GEN-LAST:event_nextSelectPartitionsButtonActionPerformed

private void optionsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_optionsButtonActionPerformed
    importOptionsDialog.setVisible(true);
    if (!importOptionsDialog.isOk()) {
        importOptionsDialog = createNewOptionsDialog(((String) outputFormatComboBox.getSelectedItem()));
    }
}//GEN-LAST:event_optionsButtonActionPerformed

private void outputFormatComboBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_outputFormatComboBoxItemStateChanged

    if (((String) outputFormatComboBox.getSelectedItem()).equals("PropertyList to Keel") || ((String) outputFormatComboBox.getSelectedItem()).equals("Weka to Keel") || ((String) outputFormatComboBox.getSelectedItem()).equals("Keel to Keel")) {
        optionsButton.setEnabled(false);
    } else {
        optionsButton.setEnabled(true);
    }

    if (((String) outputFormatComboBox.getSelectedItem()).equals("CSV to Keel") || ((String) outputFormatComboBox.getSelectedItem()).equals("TXT to Keel") || ((String) outputFormatComboBox.getSelectedItem()).equals("PRN to Keel") || ((String) outputFormatComboBox.getSelectedItem()).equals("Excel to Keel") || ((String) outputFormatComboBox.getSelectedItem()).equals("HTML Tab to Keel")) {
        processHeaderCheckBox.setEnabled(true);
    } else {
        processHeaderCheckBox.setEnabled(false);
    }

    setExtensionAndDescription();
    JFileChooser chooser = fileBrowserPanel.getFileChooser();
    chooser.resetChoosableFileFilters();
    if (ext.equals("DISABLE")) {
        chooser.setFileFilter(null);
        chooser.setVisible(false);
    } else {
        KeelFileFilter fileFilter = new KeelFileFilter();
        fileFilter.addExtension(ext);
        fileFilter.setFilterName(desc);
        chooser.setFileFilter(fileFilter);
        chooser.setVisible(true);
        //fileBrowserPanel.repaint();
    }

    importOptionsDialog = createNewOptionsDialog(((String) outputFormatComboBox.getSelectedItem()));

}//GEN-LAST:event_outputFormatComboBoxItemStateChanged

private void nextBrowserButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextBrowserButtonActionPerformed
    File originalFile = null;
    String outputFileName = null;
    if (!ext.equals("DISABLE")) {
        originalFile = fileBrowserPanel.getFileChooser().getSelectedFile();
        if (originalFile == null) {
            JOptionPane.showMessageDialog(this, "You have to select a file", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }
        outputFileName = convert(originalFile.getPath(), System.getProperty("java.io.tmpdir"));
        if (outputFileName == null) {
            return;
        } else if (outputFileName.equals("")) {
            return;
        }
    } else {
        outputFileName = convert(null, System.getProperty("java.io.tmpdir"));
    }
    tmpTrainingImportedFile = new File(outputFileName);

    if (!ext.equals("xls") && !ext.equals("DISABLED")) {
        showText(originalFile, originalTextArea);
    } else {
        originalTextArea.setText("Previsualization not available!");
    }
    showText(tmpTrainingImportedFile, resultTextArea);

    informationPreviewLabel.setText("This is a previsualization of the result of importing the file you have given");
    String format = ((String) outputFormatComboBox.getSelectedItem());
    if (!ext.equals("DISABLED")) {
        originalLabel.setText("Original File " + originalFile.getName() + " (" + format.substring(0, format.length() - 7) + " format)");
    } else {
        originalLabel.setText("Original Database (" + format.substring(0, format.length() - 7) + " format)");
    }
    resultsLabel.setText("Imported File " + tmpTrainingImportedFile.getName() + " (KEEL format)");
    lastSelectedPanel = "Browser";
    ((CardLayout) this.getLayout()).show(this, "Preview");
    Path.setFilePath(fileBrowserPanel.getFileChooser().getCurrentDirectory());
    fileBrowserPanel1.getFileChooser().setCurrentDirectory(Path.getFilePath());

    this.importToExperimentCheckBox.setEnabled(showInsertKeel);
    if (!showInsertKeel) {
        this.importToExperimentCheckBox.setSelected(true);
        this.realComboBox.setEnabled(true);
        this.partitionComboBox.setEnabled(false);
        this.userDatasetCheckBox.setEnabled(true);
        if (kfold) {
            this.partitionComboBox.setSelectedIndex(0);
        } else {
            this.partitionComboBox.setSelectedIndex(1);
        }

    } else {
        this.importToExperimentCheckBox.setSelected(true);

        this.realComboBox.setEnabled(true);
        this.userDatasetCheckBox.setEnabled(true);
        if (!datasets) {
            this.partitionComboBox.setEnabled(true);
        } else {
            this.partitionComboBox.setEnabled(false);
        }
    }
}//GEN-LAST:event_nextBrowserButtonActionPerformed

private void backBrowserButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_backBrowserButtonActionPerformed
    lastSelectedPanel = "Browser";
    ((CardLayout) this.getLayout()).show(this, "Select");
    Path.setFilePath(fileBrowserPanel.getFileChooser().getCurrentDirectory());
    fileBrowserPanel1.getFileChooser().setCurrentDirectory(Path.getFilePath());
}//GEN-LAST:event_backBrowserButtonActionPerformed

private void nextPreviewButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextPreviewButtonActionPerformed
    String outputPath = "", rootName = "";

    // -------------------------------------
    // Partition Mode
    if (!datasets) {
        try {
            if (importToExperimentCheckBox.isSelected()) {
                //rootName = addDatasetXML(tmpTrainingImportedFile, tmpTestingImportedFile);
                rootName = addDatasetXMLPartitions(tmpTrainingImportedFile, tmpTestingImportedFile);

                if (rootName == null) {
                    JOptionPane.showMessageDialog(this, "Error including the file in the experiment section", "Error", JOptionPane.ERROR_MESSAGE);
                    return;
                } else {
                    outputPath = "." + File.separator + "data" + File.separator + rootName + File.separator;
                    File directory = new File(outputPath);
                    if (!directory.exists()) {
                        if (!directory.mkdirs()) {
                            JOptionPane.showMessageDialog(this, "Problem Creating Directory", "Error", JOptionPane.ERROR_MESSAGE);
                            return;
                        }
                    }
                }
            } else {
                JFileChooser chooser = new JFileChooser();
                chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
                chooser.setDialogTitle("Select a folder to save the files");
                chooser.setCurrentDirectory(Path.getFilePath());

                String name = tmpTrainingImportedFile.getName();
                int index = name.indexOf("-");
                if (index == -1) {
                    index = name.lastIndexOf(".");
                }
                if (index == -1) {
                    index = name.length();
                }
                name = name.substring(0, index);
                chooser.setSelectedFile(new File(Path.getFilePath() + File.separator + name));

                int returnVal = chooser.showSaveDialog(this);
                if (returnVal == JFileChooser.APPROVE_OPTION) {
                    Path.setFilePath(chooser.getCurrentDirectory());

                    File directory = new File(chooser.getSelectedFile().getPath());
                    if (!directory.exists()) {
                        if (!directory.mkdirs()) {
                            JOptionPane.showMessageDialog(this, "Problem Creating Directory", "Error", JOptionPane.ERROR_MESSAGE);
                            return;
                        }
                    }

                    outputPath = directory.getPath();
                    if (!outputPath.endsWith(File.separator)) {
                        outputPath = outputPath.concat(File.separator);
                    }
                } else {
                    return;
                }
            }

            String[] trainingOutputFileName = new String[trainingModel.size()];
            String[] testOutputFileName = new String[trainingModel.size()];

            String partition = "";
            if (partitionComboBox.getSelectedIndex() == 0) {
                partition = Integer.toString(trainingModel.size());
            } else if (partitionComboBox.getSelectedIndex() == 1) {
                partition = "5x2";
            }
            for (int i = 0; i < trainingOutputFileName.length; i++) {
                if (importToExperimentCheckBox.isSelected()) {
                    trainingOutputFileName[i] = outputPath + rootName + "-" + partition + "-" + (i + 1) + "tra.dat";
                    testOutputFileName[i] = outputPath + rootName + "-" + partition + "-" + (i + 1) + "tst.dat";

                } else {
                    trainingOutputFileName[i] = outputPath + (new File((String) trainingModel.getElementAt(i))).getName().replaceAll("." + ext, "tra.dat");
                    testOutputFileName[i] = outputPath + (new File((String) testingModel.getElementAt(i))).getName().replaceAll("." + ext, "tst.dat");
                }
            }

            for (int i = 0; i < trainingModel.size(); i++) {
                if (!wantToBeOverwritten(new File(trainingOutputFileName[i])) || !wantToBeOverwritten(new File(testOutputFileName[i]))) {
                    return;
                }
            }

            if(isUnsupervised){
               // Loading one data set to extract statitics
                keel.Dataset.InstanceSet iSet = new keel.Dataset.InstanceSet();
                try {
                    Attributes.clearAll();
                    iSet.readSet(tmpTrainingImportedFile.getPath(), true);
                } catch (Exception ex) {
                    System.out.println(
                        "READING DATASET ERROR. The format of the header is not correct.");
                    ex.printStackTrace();
                    return;
                }
                deleteOutputs(tmpTrainingImportedFile,iSet);
                
                iSet = new keel.Dataset.InstanceSet();
                try {
                    Attributes.clearAll();
                    iSet.readSet(tmpTestingImportedFile.getPath(), true);
                } catch (Exception ex) {
                    System.out.println(
                        "READING DATASET ERROR. The format of the header is not correct.");
                    ex.printStackTrace();
                    return;
                }
                deleteOutputs(tmpTestingImportedFile,iSet);
            }

            FileUtils.copy(tmpTrainingImportedFile.getPath(), trainingOutputFileName[0]);
            FileUtils.copy(tmpTestingImportedFile.getPath(), testOutputFileName[0]);

            for (int i = 1; i < trainingModel.size(); i++) {
                File originalTrainingFile = new File((String) trainingModel.getElementAt(i));
                File originalTestFile = new File((String) testingModel.getElementAt(i));

                if (trainingOutputFileName == null || testOutputFileName == null) {
                    return;
                } else if (trainingOutputFileName.equals("") || testOutputFileName.equals("")) {
                    return;
                }

                String trainingConverted = convert(originalTrainingFile.getPath(), System.getProperty("java.io.tmpdir"));
                String testingConverted = convert(originalTestFile.getPath(), System.getProperty("java.io.tmpdir"));
                
                try {
                    unifyHeader(trainingConverted, testingConverted);
                } catch (IOException ex) {
                    JOptionPane.showMessageDialog(this, "Error when joining training and test files:\n" + originalTrainingFile.getName() + " " + originalTestFile.getName() + ex.getLocalizedMessage(), "Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
                if (importToExperimentCheckBox.isSelected()) {
                    if(isUnsupervised){
                        keel.Dataset.InstanceSet iSet = new keel.Dataset.InstanceSet();

                        try {
                            Attributes.clearAll();
                            iSet.readSet(trainingConverted, true);
                        } catch (Exception ex) {
                            System.out.println(
                            "READING DATASET ERROR. The format of the header is not correct.");
                            ex.printStackTrace();
                            return;
                        }
                        deleteOutputs(new File(trainingConverted),iSet);

                        iSet = new keel.Dataset.InstanceSet();
                        try {
                            Attributes.clearAll();
                            iSet.readSet(testingConverted, true);
                        } catch (Exception ex) {
                            System.out.println(
                            "READING DATASET ERROR. The format of the header is not correct.");
                            ex.printStackTrace();
                            return;
                        }
                        deleteOutputs(new File(testingConverted),iSet);
                    }
                    
                    FileUtils.copy(trainingConverted, trainingOutputFileName[i]);
                    FileUtils.copy(testingConverted, testOutputFileName[i]);
                    joinUnifiedFiles(trainingConverted, testingConverted, outputPath + File.separator + rootName + ".dat");
                    (new File(trainingConverted)).delete();
                    (new File(testingConverted)).delete();
                }
            }
            ((CardLayout) this.getLayout()).show(this, "Select");
            datasets = false;
        } catch (IOException ex) {
            Logger.getLogger(ImportPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    // -------------------------------------
    // Dataset Mode
    else {
        File file = null;
        if (importToExperimentCheckBox.isSelected()) {
            rootName = addDatasetXML(tmpTrainingImportedFile, null);
            if (rootName == null) {
                JOptionPane.showMessageDialog(this, "Error including the file in the experiment section", "Error", JOptionPane.ERROR_MESSAGE);
                return;
            }
            File directory = new File("." + File.separator +
                    "data" + File.separator +
                    rootName);
            if (!directory.exists()) {
                if (!directory.mkdirs()) {
                    JOptionPane.showMessageDialog(this, "Problem Creating Directory", "Error", JOptionPane.ERROR_MESSAGE);
                    return;
                }
            }
            file = new File(directory.getPath() + File.separator +
                    rootName + ".dat");
        } else {
            JFileChooser chooser = new JFileChooser();
            KeelFileFilter fileFilter = new KeelFileFilter();
            fileFilter.addExtension("dat");
            fileFilter.setFilterName("KEEL Files (.dat)");
            chooser.setFileFilter(fileFilter);

            chooser.setCurrentDirectory(Path.getFilePath());

            String name = tmpTrainingImportedFile.getName();
            int index = name.indexOf("-");
            if (index == -1) {
                index = name.lastIndexOf(".");
            }
            if (index == -1) {
                index = name.length();
            }
            name = name.substring(0, index);
            chooser.setSelectedFile(new File(Path.getFilePath() + File.separator + name + ".dat"));

            //chooser.setName(ext);
            int returnVal = chooser.showSaveDialog(this);
            if (returnVal == JFileChooser.APPROVE_OPTION) {
                Path.setFilePath(chooser.getCurrentDirectory());
                file = chooser.getSelectedFile();

            } else {
                return;
            }
        }
        if (file != null && !wantToBeOverwritten(file)) {
            return;
        }


        try {
            FileUtils.copy(tmpTrainingImportedFile.getPath(), file.getPath());
            tmpTrainingImportedFile.delete();
        } catch (IOException ex) {
            JOptionPane.showMessageDialog(this, "Error importing data file:\n" + ex.getLocalizedMessage(), "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }


        Object[] options = {"Yes", "No"};
        // Perform partitions?
        int n = JOptionPane.showOptionDialog(parent,
                "Do you want to edit this dataset?",
                "Edit dataset",
                JOptionPane.YES_NO_CANCEL_OPTION,
                JOptionPane.QUESTION_MESSAGE,
                null,
                options,
                options[1]);
        if (n == 0) {
            if (dataCFFrame != null) {
                dataCFFrame.addEditTab(file);
            }
        }
        else{
            // Perform partitions?
            n = JOptionPane.showOptionDialog(parent,
                    "Do you want to make partitions for this dataset?",
                    "Make partitions",
                    JOptionPane.YES_NO_CANCEL_OPTION,
                    JOptionPane.QUESTION_MESSAGE,
                    null,
                    options,
                    options[1]);
            if (n == 0) {
                if (dataCFFrame != null) {
                    dataCFFrame.addPartitionTab(file);
                }
            }
        }
        ((CardLayout) this.getLayout()).show(this, "Select");
        datasets = false;
        trainingModel.removeAllElements();
        testingModel.removeAllElements();

    }
}//GEN-LAST:event_nextPreviewButtonActionPerformed

private void backPreviewButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_backPreviewButtonActionPerformed
    if (tmpTrainingImportedFile != null) {
        tmpTrainingImportedFile.delete();
    }
    if (tmpTestingImportedFile != null) {
        tmpTestingImportedFile.delete();
    }
    ((CardLayout) this.getLayout()).show(this, lastSelectedPanel);
    lastSelectedPanel = "Preview";//GEN-LAST:event_backPreviewButtonActionPerformed
    }

private void nextPartitionsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_nextPartitionsButtonActionPerformed
    File originalTrainingFile = null;
    File originalTestFile = null;
    if (trainingModel.getSize() == 0 || testingModel.getSize() == 0) {
        JOptionPane.showMessageDialog(this, "You have to select at least one training/test pair of files", "Error", JOptionPane.ERROR_MESSAGE);
        return;
    }
    if (trainingModel.getSize() != testingModel.getSize()) {
        JOptionPane.showMessageDialog(this, "You have to select the same number of training and test files", "Error", JOptionPane.ERROR_MESSAGE);
        return;
    }
    originalTrainingFile = new File((String) trainingModel.firstElement());
    originalTestFile = new File((String) testingModel.firstElement());

    String trainingOutputFileName = convert(originalTrainingFile.getPath(), System.getProperty("java.io.tmpdir"));
    String testOutputFileName = convert(originalTestFile.getPath(), System.getProperty("java.io.tmpdir"));
    if (trainingOutputFileName == null || testOutputFileName == null) {
        return;
    } else if (trainingOutputFileName.equals("") || testOutputFileName.equals("")) {
        return;
    }
    try {
        unifyHeader(trainingOutputFileName, testOutputFileName);
    } catch (IOException ex) {
        JOptionPane.showMessageDialog(this, "Error when joining training and test files:\n" + ex.getLocalizedMessage(), "Error", JOptionPane.ERROR_MESSAGE);
        return;
    }

    tmpTrainingImportedFile = new File(trainingOutputFileName);
    tmpTestingImportedFile = new File(testOutputFileName);
    if (!ext.equals("xls")) {
        showText(originalTrainingFile, originalTextArea);
    } else {
        originalTextArea.setText("Previsualization not available!");
    }
    showText(tmpTrainingImportedFile, resultTextArea);

    informationPreviewLabel.setText("This is a previsualization of the result of importing the first training file you have given");
    lastSelectedPanel = "Partitions";
    String format = ((String) outputFormatPartitionsComboBox.getSelectedItem());
    originalLabel.setText("Original File " + originalTrainingFile.getName() + " (" + format.substring(0, format.length() - 7) + " format)");
    resultsLabel.setText("Imported File " + tmpTrainingImportedFile.getName() + " (KEEL format)");
    ((CardLayout) this.getLayout()).show(this, "Preview");

    Path.setFilePath(fileBrowserPanel1.getFileChooser().getCurrentDirectory());
    fileBrowserPanel.getFileChooser().setCurrentDirectory(Path.getFilePath());

    this.importToExperimentCheckBox.setEnabled(showInsertKeel);
    if (!showInsertKeel) {
        this.importToExperimentCheckBox.setSelected(true);
        this.realComboBox.setEnabled(true);
        this.partitionComboBox.setEnabled(true);
        this.userDatasetCheckBox.setEnabled(true);
        if (kfold) {
            this.partitionComboBox.setSelectedIndex(0);
        } else {
            this.partitionComboBox.setSelectedIndex(1);
        }
    } else {
        this.importToExperimentCheckBox.setSelected(true);

        this.realComboBox.setEnabled(true);
        this.userDatasetCheckBox.setEnabled(true);
        if (!datasets) {
            this.partitionComboBox.setEnabled(true);
        } else {
            this.partitionComboBox.setEnabled(false);
        }
    }


}//GEN-LAST:event_nextPartitionsButtonActionPerformed

private void backPartitionsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_backPartitionsButtonActionPerformed
    lastSelectedPanel = "Partitions";
    ((CardLayout) this.getLayout()).show(this, "Select");
    Path.setFilePath(fileBrowserPanel1.getFileChooser().getCurrentDirectory());
    fileBrowserPanel.getFileChooser().setCurrentDirectory(Path.getFilePath());
}//GEN-LAST:event_backPartitionsButtonActionPerformed

private void addTrainingButtonaddButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addTrainingButtonaddButtonActionPerformed
    File[] files = fileBrowserPanel1.getFileChooser().getSelectedFiles();

    if (files != null) {
        for (int i = 0; i < files.length; i++) {
            if (!trainingModel.contains(files[i].getPath())) {
                trainingModel.addElement(files[i].getPath());
            }
        }
    }
}//GEN-LAST:event_addTrainingButtonaddButtonActionPerformed



private void removeTrainingButtonremoveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeTrainingButtonremoveButtonActionPerformed
    Object[] seleccionados = trainingList.getSelectedValues();
    if (seleccionados != null) {
        for (int i = 0; i < seleccionados.length; i++) {
            trainingModel.removeElement(seleccionados[i]);
        }
    }
}//GEN-LAST:event_removeTrainingButtonremoveButtonActionPerformed

private void addTestingButtonaddButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addTestingButtonaddButtonActionPerformed
    File[] files = fileBrowserPanel1.getFileChooser().getSelectedFiles();

    if (files != null) {
        for (int i = 0; i < files.length; i++) {
            if (!testingModel.contains(files[i].getPath())) {
                testingModel.addElement(files[i].getPath());
            }
        }
    }
}//GEN-LAST:event_addTestingButtonaddButtonActionPerformed

private void removeTestingButtonremoveButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeTestingButtonremoveButtonActionPerformed
    int[] indices = testingList.getSelectedIndices();
    if (indices != null) {
        for (int i = 0; i < indices.length; i++) {
            testingModel.remove(i);
        }
    }
}//GEN-LAST:event_removeTestingButtonremoveButtonActionPerformed

private void optionsPartitionsButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_optionsPartitionsButtonActionPerformed
    importOptionsDialog.setVisible(true);
    if (!importOptionsDialog.isOk()) {
        importOptionsDialog = createNewOptionsDialog(((String) outputFormatPartitionsComboBox.getSelectedItem()));
    }
}//GEN-LAST:event_optionsPartitionsButtonActionPerformed

private void outputFormatPartitionsComboBoxItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_outputFormatPartitionsComboBoxItemStateChanged
    if (((String) outputFormatPartitionsComboBox.getSelectedItem()).equals("PropertyList to Keel") || ((String) outputFormatPartitionsComboBox.getSelectedItem()).equals("Weka to Keel") || ((String) outputFormatPartitionsComboBox.getSelectedItem()).equals("Keel to Keel")) {
        optionsPartitionsButton.setEnabled(false);
    } else {
        optionsPartitionsButton.setEnabled(true);
    }
    setExtensionAndDescription();


    if (((String) outputFormatPartitionsComboBox.getSelectedItem()).equals("CSV to Keel") || ((String) outputFormatPartitionsComboBox.getSelectedItem()).equals("TXT to Keel") || ((String) outputFormatPartitionsComboBox.getSelectedItem()).equals("PRN to Keel") || ((String) outputFormatPartitionsComboBox.getSelectedItem()).equals("Excel to Keel") || ((String) outputFormatPartitionsComboBox.getSelectedItem()).equals("HTML Tab to Keel")) {
        processHeaderPartitionsCheckBox.setEnabled(true);
    } else {
        processHeaderPartitionsCheckBox.setEnabled(false);
    }

    JFileChooser chooser = fileBrowserPanel1.getFileChooser();
    chooser.resetChoosableFileFilters();

    KeelFileFilter fileFilter = new KeelFileFilter();
    fileFilter.addExtension(ext);
    fileFilter.setFilterName(desc);
    chooser.setFileFilter(fileFilter);

    trainingModel.removeAllElements();
    testingModel.removeAllElements();

    importOptionsDialog = createNewOptionsDialog(((String) outputFormatPartitionsComboBox.getSelectedItem()));
}//GEN-LAST:event_outputFormatPartitionsComboBoxItemStateChanged

private void optionsPartitionsButtonItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_optionsPartitionsButtonItemStateChanged
}//GEN-LAST:event_optionsPartitionsButtonItemStateChanged

private void cleanButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cleanButtonActionPerformed
    trainingModel.removeAllElements();
    testingModel.removeAllElements();
}//GEN-LAST:event_cleanButtonActionPerformed

private void importToExperimentCheckBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_importToExperimentCheckBoxActionPerformed
    if (importToExperimentCheckBox.isSelected()) {
        this.realComboBox.setEnabled(true);
        this.userDatasetCheckBox.setEnabled(true);
        if (!datasets) {
            this.partitionComboBox.setEnabled(true);
        } else {
            this.partitionComboBox.setEnabled(false);
        }
    } else {
        this.realComboBox.setEnabled(false);
        this.userDatasetCheckBox.setEnabled(false);
        this.partitionComboBox.setEnabled(false);
    }
}//GEN-LAST:event_importToExperimentCheckBoxActionPerformed
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addTestingButton;
    private javax.swing.JButton addTrainingButton;
    private javax.swing.JButton backBrowserButton;
    private javax.swing.JButton backPartitionsButton;
    private javax.swing.JButton backPreviewButton;
    private javax.swing.JPanel buttonPanel;
    private javax.swing.JButton cleanButton;
    private javax.swing.JLabel datasetIcon;
    private keel.GraphInterKeel.datacf.util.FileBrowserPanel fileBrowserPanel;
    private keel.GraphInterKeel.datacf.util.FileBrowserPanel fileBrowserPanel1;
    private javax.swing.JPanel importBrowserPanel;
    private javax.swing.JLabel importDatasetLabel;
    private javax.swing.JLabel importPartitionsLabel;
    private javax.swing.JPanel importPartitionsPanel;
    private javax.swing.JPanel importPreviewPanel;
    private javax.swing.JPanel importSelectMainPanel;
    private javax.swing.JPanel importSelectPanel;
    private javax.swing.JSeparator importSeparator;
    private javax.swing.JCheckBox importToExperimentCheckBox;
    private javax.swing.JPanel importToKeelPanel;
    private javax.swing.JLabel informationPreviewLabel;
    private javax.swing.JPanel leftPreviewPanel;
    private javax.swing.JPanel mainPanel;
    private javax.swing.JPanel mainPartitionsPanel;
    private javax.swing.JButton nextBrowserButton;
    private javax.swing.JButton nextPartitionsButton;
    private javax.swing.JButton nextPreviewButton;
    private javax.swing.JButton nextSelectDatasetButton;
    private javax.swing.JButton nextSelectPartitionsButton;
    private javax.swing.JButton optionsButton;
    private javax.swing.JButton optionsPartitionsButton;
    private javax.swing.JLabel originalLabel;
    private javax.swing.JScrollPane originalScrollPanel;
    private javax.swing.JSeparator originalSeparator;
    private javax.swing.JTextArea originalTextArea;
    private javax.swing.JComboBox outputFormatComboBox;
    private javax.swing.JLabel outputFormatLabel;
    private javax.swing.JComboBox outputFormatPartitionsComboBox;
    private javax.swing.JLabel outputFormatPartitionsLabel;
    private javax.swing.JPanel outputFormatPartitionsPanel;
    private javax.swing.JComboBox partitionComboBox;
    private javax.swing.JLabel partitionsIcon;
    private javax.swing.JCheckBox processHeaderCheckBox;
    private javax.swing.JCheckBox processHeaderPartitionsCheckBox;
    private javax.swing.JComboBox realComboBox;
    private javax.swing.JButton removeTestingButton;
    private javax.swing.JButton removeTrainingButton;
    private javax.swing.JScrollPane resultScrollPanel;
    private javax.swing.JSeparator resultSeparator;
    private javax.swing.JTextArea resultTextArea;
    private javax.swing.JLabel resultsLabel;
    private javax.swing.JPanel rightPreviewPanel;
    private javax.swing.JPanel testingButtons;
    private javax.swing.JList testingList;
    private javax.swing.JPanel testingPanel;
    private javax.swing.JScrollPane testingScrollPanel;
    private javax.swing.JPanel trainingButtons;
    private javax.swing.JList trainingList;
    private javax.swing.JPanel trainingPanel;
    private javax.swing.JScrollPane trainingScrollPanel;
    private javax.swing.JCheckBox userDatasetCheckBox;
    // End of variables declaration//GEN-END:variables

    /** Parent frame */
    protected JFrame parent = null;

    /** String for having an history of the last selected panel */
    protected String lastSelectedPanel = "";

    /** Dataset mode (true) or partition mode (false) */
    protected boolean datasets = false;

    /** An option dialog for obtaining the options of the import proccess */
    protected OptionsDialog importOptionsDialog = null;

    /** The model for storing the training files used in the partition mode */
    protected DefaultListModel trainingModel = new DefaultListModel();

    /** The model for storing the testing files used in the partition mode */
    protected DefaultListModel testingModel = new DefaultListModel();

    /** Extension of the format selected by the user */
    protected String ext = "csv";

    /** Description of the format selected by the user */
    protected String desc = "CSV Files (.csv)";

    /** Temporal File used for previsualizing the results of the import proccess (in training)*/
    protected File tmpTrainingImportedFile;

    /** Temporal File used for previsualizing the results of the import proccess (in testing)*/
    protected File tmpTestingImportedFile;

    /** DataCF parent frame */
    protected DataCFFrame dataCFFrame = null;
    
    /** This is used for showing or not the insert to keel option */
    protected boolean showInsertKeel = false;

    /** This is used for deciding the default option of the type of partition */
    protected boolean kfold = true;

    /**
     * <p>
     * Gets a view of Data
     * </p>
     * @return DataCFFrame View of Data
     */
    public DataCFFrame getDataCFView() {
        return dataCFFrame;
    }

    /**
     * <p>
     * Sets a boolean indicating the insert to keel option has to be shown
     * </p>
     * @param showInsertKeel The new value
     */
    public void setShowInsertKeel(boolean showInsertKeel) {
        this.showInsertKeel = showInsertKeel;
    }

    /**
     * <p>
     * Sets a boolean indicating if "kfold" is going to be the default option
     * for the type of partition in the import proccess
     * </p>
     * @param kfold The new value
     */
    public void setKfold(boolean kfold) {
        this.kfold = kfold;
    }

    /**
     * <p>
     * Sets a view for a dataset
     * </p>
     * @param dataCFFrame View for a dataset
     */
    public void setDataCFView(DataCFFrame dataCFView) {
        this.dataCFFrame = dataCFView;
    }

    /**
     * <p>
     * Sets JFrame parent
     * </p>
     * @param parent JFrame parent
     */
    public void setParent(JFrame parent) {
        this.parent = parent;
    }

    /**
     * <p>
     * Sets extensions and description of the different import formats
     * </p>
     */
    public void setExtensionAndDescription() {
        JComboBox box = null;
        if (!datasets) {
            box = outputFormatPartitionsComboBox;
        } else {
            box = outputFormatComboBox;
        }
        if (((String) box.getSelectedItem()).equals("CSV to Keel")) {
            ext = "csv";
            desc = "CSV Files (.csv)";
        } else if (((String) box.getSelectedItem()).equals("TXT to Keel")) {
            ext = "txt";
            desc = "TXT Files (.txt)";
        } else if (((String) box.getSelectedItem()).equals("PRN to Keel")) {
            ext = "prn";
            desc = "PRN Files (.prn)";
        } else if (((String) box.getSelectedItem()).equals("C4.5 to Keel")) {
            ext = "data";
            desc = "C45 Files (.data)";
        } else if (((String) box.getSelectedItem()).equals("Excel to Keel")) {
            ext = "xls";
            desc = "Excel Files (.xls)";
        } else if (((String) box.getSelectedItem()).equals("Dif to Keel")) {
            ext = "dif";
            desc = "DIF Files (.dif)";
        } else if (((String) box.getSelectedItem()).equals("PropertyList to Keel")) {
            ext = "plist";
            desc = "Properties' Files (.plist)";
        } else if (((String) box.getSelectedItem()).equals("Weka to Keel")) {
            ext = "arff";
            desc = "Weka Files (.arff)";
        } else if (((String) box.getSelectedItem()).equals("XML to Keel")) {
            ext = "xml";
            desc = "XML Files (.xml)";
        } else if (((String) box.getSelectedItem()).equals("HTML Tab to Keel")) {
            ext = "html";
            desc = "HTML Files (.html)";
        } else if (((String) box.getSelectedItem()).equals("Database SQL to Keel")) {
            ext = "DISABLE";
            desc = "Specify Options";
        } else if (((String) box.getSelectedItem()).equals("Keel to Keel")) {
            ext = "dat";
            desc = "Keel Files (.dat)";
        }
    }

    /**
     * <p>
     * Imports inputFile (in a given format) to outputFile (in KEEL format).
     * </p>
     * @param inputFile Path of the input file.
     * @param outputFile Path of the output file.
     */
    private String convert(String inputFile, String outputFile) {

        if (importOptionsDialog == null) {
            return null;
        }
        String separatorValue = "";
        String nullValueValue = "";
        //	String nombreEtiqueta="";
        String driverBd = "";
        String URLBaseDatos = "";
        String nombreTabla = "";
        String usuario = "";
        Object passw = "";
        String ficheroNombres = "";
        String ficheroDatos = "";
        Pattern p;
        Matcher m;
        String pathnameOutput = "";

        // CSV file
        // --------
        if (ext.equals("csv")) {

            File fileInput = new File(inputFile);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Input file doesn't exists", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }


            separatorValue = importOptionsDialog.getOptionValue("Separator");

            if (separatorValue.equals("")) {
                JOptionPane.showMessageDialog(this, "The separator parameter cannot be empty, change it in \"Options\"");
                return null;
            }


            nullValueValue = importOptionsDialog.getOptionValue("Null Value");

            // Process first row as the attributes names?
            boolean processHeader;
            // Partition mode
            if (!datasets) {
                processHeader = processHeaderPartitionsCheckBox.isSelected();
            } // Dataset mode
            else {
                processHeader = processHeaderCheckBox.isSelected();
            }



            String pathnameInput = inputFile;
            pathnameOutput = outputFile;
            String nullValue = nullValueValue;
            String separator = separatorValue;


            File fileInput1 = new File(pathnameInput);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));

//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


            //           pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");

            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {

                CsvToKeel csv2keel = new CsvToKeel(nullValue, separator);
                csv2keel.setProcessHeader(processHeader);
                csv2keel.Start(pathnameInput, pathnameOutput);

                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file:\nThe file does not appear to be in CSV format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }


        }//end if(checkboxCsvToKeel.getStable())

        // TXT file
        // --------
        if (ext.equals("txt")) {

            File fileInput = new File(inputFile);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Input file doesn't exists", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

            nullValueValue = importOptionsDialog.getOptionValue("Null Value");


            if (nullValueValue.equals("")) {
                JOptionPane.showMessageDialog(this, "The null value parameter cannot be empty, change it in \"Options\"");
                return null;
            }

            // Process first row as the attributes names?
            boolean processHeader;
            // Partition mode
            if (!datasets) {
                processHeader = processHeaderPartitionsCheckBox.isSelected();
            } // Dataset mode
            else {
                processHeader = processHeaderCheckBox.isSelected();
            }

            String pathnameInput = inputFile;
            pathnameOutput = outputFile;
            String nullValue = nullValueValue;


            File fileInput1 = new File(pathnameInput);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


//            pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");

            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {

                TxtToKeel txt2keel = new TxtToKeel(nullValue);
                txt2keel.setProcessHeader(processHeader);

                txt2keel.Start(pathnameInput, pathnameOutput);

                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file\nThe file does not appear to be in TXT format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

        }//end if(checkboxTxtToKeel.getState())

        // PRN file
        // --------
        if (ext.equals("prn")) {

            File fileInput = new File(inputFile);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Input file doesn't exists");
                return null;
            }

            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists");
                return null;
            }


            nullValueValue = importOptionsDialog.getOptionValue("Null Value");

            if (nullValueValue.equals("")) {
                JOptionPane.showMessageDialog(this, "The null value parameter cannot be empty, change it in \"Options\"");
                return null;
            }

            // Process first row as the attributes names?
            boolean processHeader;
            // Partition mode
            if (!datasets) {
                processHeader = processHeaderPartitionsCheckBox.isSelected();
            } // Dataset mode
            else {
                processHeader = processHeaderCheckBox.isSelected();
            }


            String pathnameInput = inputFile;
            pathnameOutput = outputFile;
            String nullValue = nullValueValue;



            File fileInput1 = new File(pathnameInput);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


//            pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");

            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {

                PrnToKeel prn2keel = new PrnToKeel(nullValue);
                prn2keel.setProcessHeader(processHeader);
                prn2keel.Start(pathnameInput, pathnameOutput);

                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file\nThe file does not appear to be in PRN format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

        }//end if(checkboxPrnToKeel.getState())

        // C4.5 file
        // ---------
        if (ext.equals("data")) {

            p = Pattern.compile("\\.names$");
            m = p.matcher(inputFile);

            if (m.find()) {
                ficheroNombres = inputFile;
                ficheroDatos = m.replaceAll(".data");
            } else {
                p = Pattern.compile("\\.data$");
                m = p.matcher(inputFile);

                if (m.find()) {
                    ficheroDatos = inputFile;
                    ficheroNombres = m.replaceAll(".names");
                } else {
                    JOptionPane.showMessageDialog(this, "Please select a data file or a names file");
                    return null;
                }
            }


            File fileInput = new File(ficheroNombres);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Names file doesn't exists");
                return null;
            }

            fileInput = new File(ficheroDatos);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Data file doesn't exists");
                return null;
            }


            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists");
                return null;
            }

            separatorValue = importOptionsDialog.getOptionValue("Separator");

            if (separatorValue.equals("")) {
                JOptionPane.showMessageDialog(this, "The separator parameter cannot be empty, change it in \"Options\"");
                return null;
            }

            String pathnameInputNames = ficheroNombres;
            String pathnameInputData = ficheroDatos;
            pathnameOutput = outputFile;
            String separator = separatorValue;


            File fileInput1 = new File(ficheroNombres);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }

//            pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");

            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {

                UciToKeel uci2keel = new UciToKeel(separator);
                uci2keel.Start(pathnameInputNames, pathnameInputData, pathnameOutput);

                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file\nThe file does not appear to be in UCI format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

        }

        // Excel file
        // ----------
        if (ext.equals("xls")) {

            File fileInput = new File(inputFile);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Input file doesn't exists");
                return null;
            }

            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists");
                return null;
            }

            nullValueValue = importOptionsDialog.getOptionValue("Null Value");



            // Process first row as the attributes names?
            boolean processHeader;
            // Partition mode
            if (!datasets) {
                processHeader = processHeaderPartitionsCheckBox.isSelected();
            } // Dataset mode
            else {
                processHeader = processHeaderCheckBox.isSelected();
            }


            String pathnameInput = inputFile;
            pathnameOutput = outputFile;
            String nullValue = nullValueValue;


            File fileInput1 = new File(pathnameInput);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


            //           pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");


            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {
                ExcelToKeel excel2keel = new ExcelToKeel(nullValue);
                excel2keel.setProcessHeader(processHeader);
                excel2keel.Start(pathnameInput, pathnameOutput);

                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file\nThe file does not appear to be in Excel format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

        }//end if(checkboxExcelToKeel.getState())

        // DIF file
        // --------
        if (ext.equals("dif")) {


            File fileInput = new File(inputFile);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Input file doesn't exists");
                return null;
            }

            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists");
                return null;
            }

            nullValueValue = importOptionsDialog.getOptionValue("Null Value");


            String pathnameInput = inputFile;
            pathnameOutput = outputFile;
            String nullValue = nullValueValue;


            File fileInput1 = new File(pathnameInput);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


//            pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");


            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {
                DifToKeel dif2keel = new DifToKeel(nullValue);

                dif2keel.Start(pathnameInput, pathnameOutput);

                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file:\nThe file does not appear to be in DIF format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }


        }//end if(checkboxDifToKeel.getState())

        // Property list file
        // ------------------
        if (ext.equals("plist")) {

            File fileInput = new File(inputFile);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Input file doesn't exists");
                return null;
            }

            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists");
                return null;
            }

            String pathnameInput = inputFile;
            pathnameOutput = outputFile;


            File fileInput1 = new File(pathnameInput);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


//            pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");


            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {
                PropertyListToKeel propertylist2keel = new PropertyListToKeel();

                propertylist2keel.Start(pathnameInput, pathnameOutput);

                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file\nThe file does not appear to be in Property List format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

        }//end if(checkboxPlistToKeel.getState())

        // Weka file
        // ---------
        if (ext.equals("arff")) {


            File fileInput = new File(inputFile);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Input file doesn't exists");
                return null;
            }

            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists");
                return null;
            }


            String pathnameInput = inputFile;
            pathnameOutput = outputFile;


            File fileInput1 = new File(pathnameInput);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


//            pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");


            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {
                WekaToKeel weka2keel = new WekaToKeel();

                weka2keel.Start(pathnameInput, pathnameOutput);

                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file\nThe file does not appear to be in Weka format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

        }//end if(checkboxWekaToKeel.getState())

        // XML file
        // --------
        if (ext.equals("xml")) {

            File fileInput = new File(inputFile);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Input file doesn't exists", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists", "Error", JOptionPane.WARNING_MESSAGE);
                return null;
            }

            nullValueValue = importOptionsDialog.getOptionValue("Null Value");

            String pathnameInput = inputFile;
            pathnameOutput = outputFile;
            String nullValue = nullValueValue;


            File fileInput1 = new File(pathnameInput);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


//            pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");


            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {
                XmlToKeel xml2keel = new XmlToKeel(nullValue, importOptionsDialog.getOptionValue("Main Label Name"));

                xml2keel.Start(pathnameInput, pathnameOutput);


                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file\nThe file does not appear to be in XML format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

        }//end if(checkboxXmlToKeel.getState())

        // HTML Tab file
        // -------------
        if (ext.equals("html")) {


            File fileInput = new File(inputFile);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Input file doesn't exists");
                return null;
            }

            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists");
                return null;
            }

            nullValueValue = importOptionsDialog.getOptionValue("Null Value");

            // Process first row as the attributes names?
            boolean processHeader;
            // Partition mode
            if (!datasets) {
                processHeader = processHeaderPartitionsCheckBox.isSelected();
            } // Dataset mode
            else {
                processHeader = processHeaderCheckBox.isSelected();
            }

            String pathnameInput = inputFile;
            pathnameOutput = outputFile;
            String nullValue = nullValueValue;


            File fileInput1 = new File(pathnameInput);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


//            pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");


            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {
                HtmlToKeel html2keel = new HtmlToKeel(nullValue);
                html2keel.setProcessHeader(processHeader);
                html2keel.Start(pathnameInput, pathnameOutput);


                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file\nThe file does not appear to be in Html format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }


        }//end if(checkboxHtmlToKeel.getState())

        // Database
        // --------
        if (ext.equals("DISABLED")) {



            driverBd = importOptionsDialog.getOptionValue("Driver");
            URLBaseDatos = importOptionsDialog.getOptionValue("Database URL");
            nombreTabla = importOptionsDialog.getOptionValue("Table Name");
            usuario = importOptionsDialog.getOptionValue("User");
            passw = importOptionsDialog.getOptionValue("Password");

            if (driverBd.equals("")) {
                JOptionPane.showMessageDialog(this, "The Driver parameter cannot be empty, change it in \"Options\"");
                return null;
            }

            if (URLBaseDatos.equals("")) {
                JOptionPane.showMessageDialog(this, "The Database-URL parameter cannot be empty, change it in \"Options\"");
                return null;
            }

            if (nombreTabla.equals("")) {
                JOptionPane.showMessageDialog(this, "The Table-Name parameter cannot be empty, change it in \"Options\"");
                return null;
            }


            String driverName = driverBd;
            String databaseURL = URLBaseDatos;
            String login = usuario;
            String password = passw.toString();
            String tableName = nombreTabla;

            pathnameOutput = outputFile;

            // Obtenemos la ruta del fichero de salida
            String filenameOutput = nombreTabla;


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


//            pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");


            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {

                DbToKeel db2keel = new DbToKeel(driverName, databaseURL, tableName, login, password);
                db2keel.Start(pathnameOutput);

                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing Database", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

        }//end if(checkboxDbToKeel.getState())

        // KEEL file
        // ---------
        if (ext.equals("dat")) {

            File fileInput = new File(inputFile);

            if (!fileInput.exists()) {
                JOptionPane.showMessageDialog(this, "Input file doesn't exists");
                return null;
            }

            File fileOutput = new File(outputFile);

            if (!fileOutput.exists()) {
                JOptionPane.showMessageDialog(this, "The output path doesn't exists");
                return null;
            }

            String pathnameInput = inputFile;
            pathnameOutput = outputFile;

            
            File fileInput1 = new File(pathnameInput);


            // Obtenemos la ruta del fichero de salida
            String filenameOutput = fileInput1.getName();


            // le quito la extension al nombre del fichero
            if (filenameOutput.lastIndexOf('.') != -1) {
                filenameOutput = filenameOutput.substring(0, filenameOutput.lastIndexOf('.'));
            }
//            String folder = filenameOutput;
            String separatorFile = File.separator;

            if (!pathnameOutput.endsWith(separatorFile)) {
                pathnameOutput = pathnameOutput.concat(separatorFile);
            }


//            pathnameOutput = pathnameOutput.concat(folder + separatorFile);

            File fileOutput1 = new File(pathnameOutput);
            fileOutput1.mkdirs();


            pathnameOutput = pathnameOutput.concat(filenameOutput);
            pathnameOutput = pathnameOutput.concat(".dat");


            this.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

            try {
                FileUtils.copy(pathnameInput, pathnameOutput);
                this.setCursor(Cursor.getDefaultCursor());
                //JOptionPane.showMessageDialog(this, "File " + fileInput.getName() + " correctly imported");
            } catch (Exception ex) {
                this.setCursor(Cursor.getDefaultCursor());
                JOptionPane.showMessageDialog(this, "Error importing data file\nThe file does not appear to be in Property List format", "Error", JOptionPane.ERROR_MESSAGE);
                return null;
            }

        }//end if(checkboxPlistToKeel.getState())


        return pathnameOutput;

    }

    /**
     * <p>
     * Shows the text of a file in a JTextArea
     * </p>
     * @param file File to be shown
     * @param textArea JTextArea to include the text
     */
    private void showText(File file, JTextArea textArea) {
        FileReader in = null;
        try {
            in = new FileReader(file);
            textArea.read(in, file.toString());
        } catch (FileNotFoundException ex) {
            ex.printStackTrace();
        } catch (IOException ex) {
            ex.printStackTrace();
        } finally {
            try {
                in.close();
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
    }

    /**
     * <p>
     * Unifies the headers of a pair of training and testing KEEL files.
     * The new header is obtained by joining the ranges for each of the
     * variables of the datasets. The files are modified and the new header
     * substitutes the old headers.
     * </p>
     * @param trainingFile Path of the KEEL training file
     * @param testingFile Path of the KEEL testing file
     */
    private void unifyHeader(String trainingFile, String testingFile) throws IOException {

        StringBuffer trainingHeader = new StringBuffer();
        StringBuffer trainingBody = new StringBuffer();
        String trainingRelation = "";
        StringBuffer testingHeader = new StringBuffer();
        StringBuffer testingBody = new StringBuffer();
        String testingRelation = "";

        BufferedReader br = new BufferedReader(new FileReader(trainingFile));
        String line;
        while (((line = br.readLine()) != null) && !line.equalsIgnoreCase("@data")) {
            trainingHeader.append(line.trim() + "\n");
        }
        trainingBody.append("@data" + "\n");
        while ((line = br.readLine()) != null) {
            trainingBody.append(line + "\n");
        }
        br = new BufferedReader(new FileReader(testingFile));
        while (((line = br.readLine()) != null) && !line.equalsIgnoreCase("@data")) {
            testingHeader.append(line.trim() + "\n");
        }
        testingBody.append("@data" + "\n");
        while ((line = br.readLine()) != null) {
            testingBody.append(line + "\n");
        }
        StringBuffer header = new StringBuffer();

        String trainingStr, testingStr;
        String outputs = "", inputs = "";

        BufferedReader trainingReader = new BufferedReader(new StringReader(trainingHeader.toString()));
        BufferedReader testingReader = new BufferedReader(new StringReader(testingHeader.toString()));
        try {
            while ((trainingStr = trainingReader.readLine()) != null) {
                if ((testingStr = testingReader.readLine()) == null) {
                    throw new IOException("Incompatible training/test files");
                }
                trainingStr = trainingStr.trim();
                testingStr = testingStr.trim();
                if (trainingStr.toLowerCase().indexOf("@attribute") != -1) {
                    if (testingStr.toLowerCase().indexOf("@attribute") == -1) {
                        throw new IOException("Incompatible training/test files");
                    }
                    Attribute trainingAttribute = parseAttribute(trainingStr);
                    Attribute testingAttribute = parseAttribute(testingStr);
                    if (trainingAttribute.getType() != testingAttribute.getType() || !(trainingAttribute.getName().equals(testingAttribute.getName()))) {
                        throw new IOException("Incompatible training/test files");
                    }
                    if (trainingAttribute.getType() == Attribute.REAL || trainingAttribute.getType() == Attribute.INTEGER) {
                        double min = trainingAttribute.getMinAttribute(), max = trainingAttribute.getMaxAttribute();
                        if (testingAttribute.getMinAttribute() < min) {
                            min = testingAttribute.getMinAttribute();
                        }
                        if (testingAttribute.getMaxAttribute() > max) {
                            max = testingAttribute.getMaxAttribute();
                        }
                        trainingAttribute.setBounds(min, max);
                    }
                    if (trainingAttribute.getType() == Attribute.NOMINAL) {
                        Vector nominalValues = testingAttribute.getNominalValuesList();
                        for (int i = 0; i < nominalValues.size(); i++) {
                            trainingAttribute.addTestNominalValue((String) nominalValues.get(i));
                        }
                    }

                    header.append(trainingAttribute.toString() + "\n");
                } else if (trainingStr.toLowerCase().indexOf("@relation") != -1) {
                    trainingRelation = trainingStr;
                    testingRelation = testingStr;
                } else if (trainingStr.toLowerCase().indexOf("@inputs") != -1) {
                    inputs = trainingStr;
                } else if (trainingStr.toLowerCase().indexOf("@outputs") != -1) {
                    outputs = trainingStr;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
        trainingReader.close();
        testingReader.close();

//        System.out.println("Header Common: " + header.toString());

        try {
            BufferedWriter trainingWriter = new BufferedWriter(new FileWriter(trainingFile));
            trainingWriter.write(trainingRelation + "\n" + header.toString() + inputs + "\n" + outputs + "\n" + trainingBody.toString());
            trainingWriter.close();
            BufferedWriter testingWriter = new BufferedWriter(new FileWriter(testingFile));
            testingWriter.write(testingRelation + "\n" + header.toString() + inputs + "\n" + outputs + "\n" + testingBody.toString());
            testingWriter.close();
        } catch (IOException e) {
            throw new IOException("Error Writing File");
        }
    }
    
    /**
     * <p>
     * Joins a pair of training and testing files (that are supposed to have the
     * same header) in an unified file with all training and testing patterns
     * </p>
     * @param trainingFile Path of the KEEL training file
     * @param testingFile Path of the KEEL testing file
     * @param unifiedFile Output path of the unified file
     */
    private void joinUnifiedFiles(String trainingFile, String testingFile, String unifiedFile) throws IOException {
        StringBuffer outputBuffer = new StringBuffer();

        BufferedReader br = new BufferedReader(new FileReader(trainingFile));
        String line;
        while (((line = br.readLine()) != null)) {
            outputBuffer.append(line.trim() + "\n");
        }
        br = new BufferedReader(new FileReader(testingFile));

        boolean afterHeader = false;
        while ((line = br.readLine()) != null) {
            if (line.equalsIgnoreCase("@data")) {
                afterHeader = true;
            } else if (afterHeader) {
                outputBuffer.append(line.trim() + "\n");
            }
        }

        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter(unifiedFile));
            writer.write(outputBuffer.toString());
            writer.close();
        } catch (IOException e) {
            throw new IOException("Error Writing File");
        }
    }

    /**
     * <p>
     * Obtains an Attribute object from a text line representing the attribute
     * in KEEL format
     * </p>
     * @param line Attribute text line
     * @return Attribute Parsed Attribute object.
     */
    protected Attribute parseAttribute(String line) {

        int indexL, indexR;
        String type;

        //Treating string and declaring a string tokenizer
        line.replace("{", " {");
        //line.replace ("["," [");

        //System.out.println ("  > Processing line: "+  line );
        StringTokenizer st = new StringTokenizer(line, " [{\t");

        //Disregarding the first token. It is @attribute
        st.nextToken();

        Attribute at = new Attribute();
        at.setName(st.nextToken().trim());
        //System.out.println ( "   > Attribute name: "+ at.getName() );

        //Next action depends on the type of attribute: continuous or nominal
        if (!st.hasMoreTokens()) { // Parsing a nominal attribute with no definition of values
            //System.out.println ("    > Parsing nominal attribute without values ");
            at.setType(Attribute.NOMINAL);
        } else if (line.indexOf("{") != -1) { // Parsing a nominal attribute
            //System.out.println ("    > Parsing nominal attribute with values: "+line );
            at.setType(Attribute.NOMINAL);
            at.setFixedBounds(true);

            indexL = line.indexOf("{");
            indexR = line.indexOf("}");

            //System.out.println ( "      > The Nominal values are: " + line.substring( indexL+1, indexR) );
            StringTokenizer st2 = new StringTokenizer(line.substring(indexL + 1, indexR), ",");

            while (st2.hasMoreTokens()) {
                at.addNominalValue(st2.nextToken().trim());
            }
        } else { //Parsing an integer or real
            type = st.nextToken().trim();

            //System.out.println ("    > Parsing "+ type + " attributes");
            if (type.equalsIgnoreCase("integer")) {
                at.setType(Attribute.INTEGER);
            }
            if (type.equalsIgnoreCase("real")) {
                at.setType(Attribute.REAL);
            }
            indexL = line.indexOf("[");
            indexR = line.indexOf("]");

            if (indexL != -1 && indexR != - 1) {
                //System.out.println ( "      > The real values are: " + line.substring( indexL+1, indexR) );
                StringTokenizer st2 = new StringTokenizer(line.substring(indexL + 1, indexR), ",");

                double min = Double.parseDouble(st2.nextToken().trim());
                double max = Double.parseDouble(st2.nextToken().trim());

                at.setBounds(min, max);
            }

        }

        return at;

    }//end insertAttribute

    /**
     * <p>
     * Creates an options dialog with the options corresponding to a type
     * of conversion
     * </p>
     * @param type String with the type of conversion
     * @return OptionsDialog New options dialog.
     */
    protected OptionsDialog createNewOptionsDialog(String type) {
        OptionsDialog newExportOptionsDialog = new OptionsDialog(parent, true);
        if (type.equals("CSV to Keel")) {
            newExportOptionsDialog.addProperty("Separator", ",");
            newExportOptionsDialog.addProperty("Null Value", "");
        } else if (type.equals("TXT to Keel")) {
            newExportOptionsDialog.addProperty("Null Value", "");
        } else if (type.equals("PRN to Keel")) {
            newExportOptionsDialog.addProperty("Null Value", "?");
        } else if (type.equals("XML to Keel")) {
            newExportOptionsDialog.addProperty("Null Value", "");
            newExportOptionsDialog.addProperty("Main Label Name", "");
        } else if (type.equals("C4.5 to Keel")) {
            newExportOptionsDialog.addProperty("Separator", ",");
        } else if (type.equals("Excel to Keel")) {
            newExportOptionsDialog.addProperty("Null Value", "");
        } else if (type.equals("Dif to Keel")) {
            newExportOptionsDialog.addProperty("Null Value", "");
        } else if (type.equals("HTML Tab to Keel")) {
            newExportOptionsDialog.addProperty("Null Value", "<null>");
        } else if (type.equals("Database SQL to Keel")) {
            newExportOptionsDialog.addProperty("Driver", "sun.jdbc.odbc.JdbcOdbcDriver");
            newExportOptionsDialog.addProperty("Database URL", "jdbc:subprotocol:subname");
            newExportOptionsDialog.addProperty("User", "");
            newExportOptionsDialog.addProperty("Password", "");
            newExportOptionsDialog.addProperty("Table Name", "");
        }
        return newExportOptionsDialog;
    }

    /**
     * <p>
     * Shows an Option Dialog for confirming if a file should be overwritten
     * (if the file exists)
     * </p>
     * @param file File object to check if it should be overwritten
     * @return boolean This value indicates if the file should be overwritten
     */
    private boolean wantToBeOverwritten(File file) {
        // Check if the file exists
        if (file.exists()) {
            // Do you want to overwrite the file?
            Object[] options = {"Yes",
                "No"
            };
            int n = JOptionPane.showOptionDialog(parent,
                    "File \"" + file.getName() + "\" exists.\nDo you want to overwrite it?",
                    "File exists",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.QUESTION_MESSAGE,
                    null,
                    options,
                    options[1]);
            if (n == 1) {
                return false;
            }
        }
        return true;
    }

    /**
     * <p>
     * Clean import panels
     * </p>
     *
     */
    public void cleanPanels(){
        this.cleanButtonActionPerformed(null);
    }

    /**
     * <p>
     * Delete all output attributes in the data set file and converts them to inputs.
     * </p>
     *
     * @param file File to process
     * @param iSet instance set associated to the data set
     * @return
     * @throws IOException File exception is the file is not read properly
     */
    private boolean deleteOutputs(File file, InstanceSet iSet) throws IOException{

        FileInputStream fstream = new FileInputStream(file.getAbsolutePath());
        DataInputStream in = new DataInputStream(fstream);
        BufferedReader br = new BufferedReader(new InputStreamReader(in));

        StringTokenizer word;
        String line;
        String text;
        String cad;

        ArrayList<String> atts= new ArrayList<String>();

        //process header
        
        text="";
        do{
            line = br.readLine();
            
            if(line.startsWith("@input")||line.startsWith("@output")||line.startsWith("@data")){
                //do not print these lines
            }
            else{
                text+=line+"\n";
                if(line.startsWith("@attribute")){
                    word=new StringTokenizer(line," ");
                    cad=word.nextToken();
                    cad=word.nextToken();
                    if(cad.contains("[")){
                        word=new StringTokenizer(cad,"[");
                        cad=word.nextToken();
                    }
                    if(cad.contains("{")){
                        word=new StringTokenizer(cad,"{");
                        cad=word.nextToken();
                    }
                    atts.add(cad);
                }
            }
        }while(!line.startsWith("@data"));
        //print @inputs line

        text+="@inputs ";
        for(int i=0;i<atts.size()-1;i++){
            text+=atts.get(i)+", ";
        }
        text+=atts.get(atts.size()-1)+"\n";

        text+="@outputs \n";
        
        //print @data line
        text+=line+"\n";

        PrintWriter aux= new PrintWriter(new FileWriter(file));
        aux.print(text);
        for(int i=0;i<iSet.getNumInstances();i++){
            iSet.getInstance(i).printAsOriginal(aux);
            aux.print("\n");
        }

        aux.close();

        return true;

    }

    /**
     * <p>
     * Adds a dataset to the "Datasets.xml" file of the experiment section
     * </p>
     * @param file Training file of the dataset
     * @param fileTesting Testing file of the dataset
     * @return String Root name for the dataset finally added to experiment
     *                section (null if there is any problem)
     */
    private String addDatasetXML(File file, File fileTesting) {

        isUnsupervised=false;
        /*Load the previuos datasets.xml*/
        Document data = new Document();
        try {
            SAXBuilder builder = new SAXBuilder();
            data = builder.build("./data/Datasets.xml");
        } catch (JDOMException ex) {
            ex.printStackTrace();
        } catch (Exception ex) {
            ex.printStackTrace();
            System.out.println("Dataset specification XML file not found");
            return null;
        }


        String rootName = (String) JOptionPane.showInputDialog(
                parent,
                "Insert a name for the dataset to be used in the experiment section:",
                "Insert name",
                JOptionPane.PLAIN_MESSAGE,
                null,
                null,
                file.getName().replaceAll(".dat", ""));

        //minusculas
        String lowerCaseName= rootName.toLowerCase();

        Iterator it = data.getRootElement().getChildren().iterator();
        while (it.hasNext()) {
            Element element = (Element) it.next();
            if (element.getChild("nameAbr").getValue().equals(lowerCaseName)) {
                rootName = (String) JOptionPane.showInputDialog(
                            parent,
                            "The name of the dataset is also included in the experiment section.\n" + "Please insert another name:",
                            "Existing name",
                            JOptionPane.PLAIN_MESSAGE,
                            null,
                            null,
                            rootName);
                if( ((rootName == null) || (rootName.length() == 0))){
                    return null;
                }
		lowerCaseName= rootName.toLowerCase();
				
                it = data.getRootElement().getChildren().iterator();
            }
        }

        // Loading one data set to extract statitics
        keel.Dataset.InstanceSet iSet = new keel.Dataset.InstanceSet();
        try {
            Attributes.clearAll();
            iSet.readSet(file.getPath(), true);
        } catch (Exception ex) {
            System.out.println(
                    "READING DATASET ERROR. The format of the header is not correct.");
            ex.printStackTrace();
            return null;
        }

        Element root = new Element("dataset");
        Element nameAbr = new Element("nameAbr");
        nameAbr.setText(lowerCaseName);
        Element nameComplete = new Element("nameComplete");
        nameComplete.setText(rootName);

        boolean classification = false;
        Element problemType = new Element("problemType");

        if(Attributes.getOutputNumAttributes()==0){
            problemType.setText("Unsupervised");
        }
        else{
            if (Attributes.getOutputAttribute(0).getType() == Attribute.NOMINAL) {
                classification = true;
            }

            if (classification) {
                if(iSet.isOutputInfered()){
                    problemType.setText("Unsupervised");
                    isUnsupervised = true;
                }
                else{
                    problemType.setText("Classification");
                    isUnsupervised = false;
                }
            } else {
                problemType.setText("Regression");
                isUnsupervised = false;
            }
        }

        //Custom button text
        Object[] options = {"Classification",
                    "Regression",
                    "Unsupervised"};
        int optionType = JOptionPane.showOptionDialog(parent,
            "Select the type of problem",
            "Select type",
            JOptionPane.YES_NO_CANCEL_OPTION,
            JOptionPane.QUESTION_MESSAGE,
            null,
            options,
            options[0]);

        if(optionType==0){
            classification = true;
            problemType.setText("Classification");
            isUnsupervised = false;
        }
        else if(optionType==1){
            classification = false;
            problemType.setText("Regression");
            isUnsupervised = false;
        }
        else if(optionType==2){
            classification = false;
            problemType.setText("Unsupervised");
            isUnsupervised = true;
        }
        else{
            //Use default classification
        }

        if(isUnsupervised==true){
            try {
                deleteOutputs(file,iSet);
            } catch (IOException ex) {
                System.out.println(
                    "READING DATASET ERROR. The format of the header is not correct.");
                ex.printStackTrace();
                return null;
            }
            JOptionPane.showMessageDialog(this, "All attributes have been automatically defined as inputs for this unsupervised data set problem.", "Attributes modified", JOptionPane.INFORMATION_MESSAGE);
        }

        Element partitions = new Element("partitions");
        if (!datasets) {
            if (partitionComboBox.getSelectedIndex() == 0) {
                Element partition = new Element("partition");
                partition.setText(trainingModel.size() + "cfv");
                partitions.addContent(partition);
            } else if (partitionComboBox.getSelectedIndex() == 1) {
                Element partition = new Element("partition");
                partition.setText("5x2cv");
                partitions.addContent(partition);
            }
        }
        Element continuosValues = new Element("continuous");
        if (keel.Dataset.Attributes.hasRealAttributes()) {
            continuosValues.setText("Yes");
        } else {
            continuosValues.setText("No");
        }

        Element discreteValues = new Element("integer");
        if (keel.Dataset.Attributes.hasIntegerAttributes()) {
            discreteValues.setText("Yes");
        } else {
            discreteValues.setText("No");
        }

        Element nominalValues = new Element("nominal");
        if (keel.Dataset.Attributes.hasNominalAttributes()) {
            nominalValues.setText("Yes");
        } else {
            nominalValues.setText("No");
        }

        Element impreciseValues = new Element("imprecise");
        impreciseValues.setText("No");

        int numMissing = 0;
        for (int is = 0; is < iSet.getNumInstances(); is++) {
            if (iSet.getInstance(is).existsAnyMissingValue()) {
                numMissing++;
            }
        }
        double percMV = (double) numMissing /
                (double) iSet.getNumInstances();
        Element percMissingValues = new Element("percMissingValues");
        percMissingValues.setText(String.valueOf(percMV));

        Element missingValues = new Element("missing");
        if (keel.Dataset.Attributes.hasMissingValues()) {
            missingValues.setText("Yes");
        } else {
            missingValues.setText("No");
        }

        Element multiOutput = new Element("multioutput");
        if (keel.Dataset.Attributes.getOutputNumAttributes() > 1) {
            multiOutput.setText("Yes");
        } else {
            multiOutput.setText("No");
        }

        Element multiClass = new Element("multiclass");
        if (keel.Dataset.Attributes.getOutputNumAttributes() == 1) {
            keel.Dataset.Attribute att = keel.Dataset.Attributes.getOutputAttribute(0);
            if (att.getType() == keel.Dataset.Attribute.NOMINAL &&
                    att.getNumNominalValues() == 2) {
                multiClass.setText("No");
            } else {
                multiClass.setText("Yes");
            }
        } else {
            multiClass.setText("Yes");
        }

        root.addContent(nameAbr).addContent(nameComplete).addContent(
                problemType).addContent(partitions).addContent(
                continuosValues).
                addContent(discreteValues).addContent(nominalValues).
                addContent(impreciseValues).addContent(missingValues).
                addContent(percMissingValues).addContent(multiOutput).
                addContent(multiClass);

        Element field = new Element("field");
        if (realComboBox.getSelectedIndex() == 0) {
            field.setText("Real");
        } else if (realComboBox.getSelectedIndex() == 1) {
            field.setText("Laboratory");
        }

        Element nAttributes = new Element("nAttributes");
        nAttributes.setText(Integer.toString(keel.Dataset.Attributes.getNumAttributes()));
        root.addContent(nAttributes);

        Element nInstances = new Element("nInstances");
        int testingInstances = 0;
        if (fileTesting != null) {
            // Loading one data set to extract statitics
            keel.Dataset.InstanceSet iSet2 = new keel.Dataset.InstanceSet();
            try {
                System.out.println(file.getPath());
                iSet2.readSet(file.getPath(), false);
            } catch (Exception ex) {
                System.out.println(
                        "READING DATASET ERROR. The format of the header is not correct.");
                ex.printStackTrace();
                return null;
            }
            testingInstances = iSet2.getNumInstances();

        }
        nInstances.setText(Integer.toString(iSet.getNumInstances() + testingInstances));
        root.addContent(nInstances);

        if (classification) {
            int numClasses;
            keel.Dataset.Attribute a = keel.Dataset.Attributes.getOutputAttribute(0);
            if (a.getType() == keel.Dataset.Attribute.NOMINAL) {
                numClasses = a.getNumNominalValues();
            } else {
                numClasses = (int) (a.getMaxAttribute() - a.getMinAttribute());
            }
            Element nClasses = new Element("nClasses");
            nClasses.setText(Integer.toString(numClasses));
            root.addContent(nClasses);
        }

        if (userDatasetCheckBox.isSelected()) {
            Element userDataset = new Element("userDataset");
            root.addContent(field).addContent(userDataset);
        }


        data.getRootElement().addContent(root);

        try {
            File f = new File("./data/Datasets.xml");
            FileOutputStream file2 = new FileOutputStream(f);
            XMLOutputter fmt = new XMLOutputter();
            fmt.setFormat(Format.getPrettyFormat());
            fmt.output(data, file2);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        Attributes.clearAll();

        //return name in lowerCase
        return lowerCaseName;
    }

    /**
     * <p>
     * Adds a dataset to the "Datasets.xml" file of the experiment section
     * </p>
     * @param file Training file of the dataset
     * @param fileTesting Testing file of the dataset
     * @return String Root name for the dataset finally added to experiment
     *                section (null if there is any problem)
     */
    private String addDatasetXMLPartitions(File file, File fileTesting) {

        boolean overwrite= false;

        /*Load the previuos datasets.xml*/
        Document data = new Document();
        try {
            SAXBuilder builder = new SAXBuilder();
            data = builder.build("./data/Datasets.xml");
        } catch (JDOMException ex) {
            ex.printStackTrace();
        } catch (Exception ex) {
            ex.printStackTrace();
            System.out.println("Dataset specification XML file not found");
            return null;
        }


        String rootName = (String) JOptionPane.showInputDialog(
                parent,
                "Insert a name for the dataset to be used in the experiment section:",
                "Insert name",
                JOptionPane.PLAIN_MESSAGE,
                null,
                null,
                file.getName().replaceAll(".dat", ""));

        //minusculas
        String lowerCaseName= rootName.toLowerCase();

        Iterator it = data.getRootElement().getChildren().iterator();
        while (it.hasNext()) {
            Element element = (Element) it.next();
            if (element.getChild("nameAbr").getValue().equals(lowerCaseName)) {

                // Do you want to overwrite the file?
                 Object[] options = {"Yes", "No"};
                 int n = JOptionPane.showOptionDialog(parent,
                    "Data set \""+ rootName + "\" already exists.\nExisting partitions will be overwritten.\n Are you sure?",
                    "Data set exists",
                    JOptionPane.YES_NO_OPTION,
                    JOptionPane.QUESTION_MESSAGE,
                    null,
                    options,
                    options[1]);
                if (n == 1) {

                    
                        rootName = (String) JOptionPane.showInputDialog(
                                parent,
                                "The name of the dataset is also included in the experiment section.\n" + "Please insert another name:",
                                "Existing name",
                                JOptionPane.PLAIN_MESSAGE,
                                null,
                                null,
                                rootName);
                    if( ((rootName == null) || (rootName.length() == 0))){
                        return null;
                    }
					lowerCaseName= rootName.toLowerCase();
                    it = data.getRootElement().getChildren().iterator();
                }
                else{
                    overwrite= true;
                }
            }
        }

        if(!overwrite){
        // Loading one data set to extract statitics
        keel.Dataset.InstanceSet iSet = new keel.Dataset.InstanceSet();
        try {
            Attributes.clearAll();
            iSet.readSet(file.getPath(), true);
        } catch (Exception ex) {
            System.out.println(
                    "READING DATASET ERROR. The format of the header is not correct.");
            ex.printStackTrace();
            return null;
        }

        Element root = new Element("dataset");
        Element nameAbr = new Element("nameAbr");
        nameAbr.setText(lowerCaseName);
        Element nameComplete = new Element("nameComplete");
        nameComplete.setText(rootName);

        boolean classification = false;
        Element problemType = new Element("problemType");

        if(Attributes.getOutputNumAttributes()==0){
            problemType.setText("Unsupervised");
        }
        else{
            if (Attributes.getOutputAttribute(0).getType() == Attribute.NOMINAL) {
                classification = true;
            }

            if (classification) {
                if(iSet.isOutputInfered()){
                    problemType.setText("Unsupervised");
                    isUnsupervised = true;
                }
                else{
                    problemType.setText("Classification");
                    isUnsupervised = false;
                }
            } else {
                problemType.setText("Regression");
                isUnsupervised = false;
            }
        }

        //Custom button text
        Object[] options = {"Classification",
                    "Regression",
                    "Unsupervised"};
        int optionType = JOptionPane.showOptionDialog(parent,
            "Select the type of problem",
            "Select type",
            JOptionPane.YES_NO_CANCEL_OPTION,
            JOptionPane.QUESTION_MESSAGE,
            null,
            options,
            options[0]);

        if(optionType==0){
            classification = true;
            problemType.setText("Classification");
            isUnsupervised = false;
        }
        else if(optionType==1){
            classification = false;
            problemType.setText("Regression");
            isUnsupervised = false;
        }
        else if(optionType==2){
            classification = false;
            problemType.setText("Unsupervised");
            isUnsupervised = true;
        }
        else{
            //Use default classification
        }

        if(isUnsupervised){
            JOptionPane.showMessageDialog(this, "All attributes have been automatically defined as inputs for this unsupervised data set problem.", "Attributes modified", JOptionPane.INFORMATION_MESSAGE);
        }

        Element partitions = new Element("partitions");
        if (!datasets) {
            if (partitionComboBox.getSelectedIndex() == 0) {
                Element partition = new Element("partition");
                partition.setText(trainingModel.size() + "cfv");
                partitions.addContent(partition);
            } else if (partitionComboBox.getSelectedIndex() == 1) {
                Element partition = new Element("partition");
                partition.setText("5x2cv");
                partitions.addContent(partition);
            }
        }
        Element continuosValues = new Element("continuous");
        if (keel.Dataset.Attributes.hasRealAttributes()) {
            continuosValues.setText("Yes");
        } else {
            continuosValues.setText("No");
        }

        Element discreteValues = new Element("integer");
        if (keel.Dataset.Attributes.hasIntegerAttributes()) {
            discreteValues.setText("Yes");
        } else {
            discreteValues.setText("No");
        }

        Element nominalValues = new Element("nominal");
        if (keel.Dataset.Attributes.hasNominalAttributes()) {
            nominalValues.setText("Yes");
        } else {
            nominalValues.setText("No");
        }

        Element impreciseValues = new Element("imprecise");
        impreciseValues.setText("No");

        int numMissing = 0;
        for (int is = 0; is < iSet.getNumInstances(); is++) {
            if (iSet.getInstance(is).existsAnyMissingValue()) {
                numMissing++;
            }
        }
        double percMV = (double) numMissing /
                (double) iSet.getNumInstances();
        Element percMissingValues = new Element("percMissingValues");
        percMissingValues.setText(String.valueOf(percMV));

        Element missingValues = new Element("missing");
        if (keel.Dataset.Attributes.hasMissingValues()) {
            missingValues.setText("Yes");
        } else {
            missingValues.setText("No");
        }

        Element multiOutput = new Element("multioutput");
        if (keel.Dataset.Attributes.getOutputNumAttributes() > 1) {
            multiOutput.setText("Yes");
        } else {
            multiOutput.setText("No");
        }

        Element multiClass = new Element("multiclass");
        if (keel.Dataset.Attributes.getOutputNumAttributes() == 1) {
            keel.Dataset.Attribute att = keel.Dataset.Attributes.getOutputAttribute(0);
            if (att.getType() == keel.Dataset.Attribute.NOMINAL &&
                    att.getNumNominalValues() == 2) {
                multiClass.setText("No");
            } else {
                multiClass.setText("Yes");
            }
        } else {
            multiClass.setText("Yes");
        }

        root.addContent(nameAbr).addContent(nameComplete).addContent(
                problemType).addContent(partitions).addContent(
                continuosValues).
                addContent(discreteValues).addContent(nominalValues).
                addContent(impreciseValues).addContent(missingValues).
                addContent(percMissingValues).addContent(multiOutput).
                addContent(multiClass);

        Element field = new Element("field");
        if (realComboBox.getSelectedIndex() == 0) {
            field.setText("Real");
        } else if (realComboBox.getSelectedIndex() == 1) {
            field.setText("Laboratory");
        }

        Element nAttributes = new Element("nAttributes");
        nAttributes.setText(Integer.toString(keel.Dataset.Attributes.getNumAttributes()));
        root.addContent(nAttributes);

        Element nInstances = new Element("nInstances");
        int testingInstances = 0;
        if (fileTesting != null) {
            // Loading one data set to extract statitics
            keel.Dataset.InstanceSet iSet2 = new keel.Dataset.InstanceSet();
            try {
                System.out.println(fileTesting.getPath());
                iSet2.readSet(fileTesting.getPath(), false);
            } catch (Exception ex) {
                System.out.println(
                        "READING DATASET ERROR. The format of the header is not correct.");
                ex.printStackTrace();
                return null;
            }
            testingInstances = iSet2.getNumInstances();

        }
        nInstances.setText(Integer.toString(iSet.getNumInstances() + testingInstances));
        root.addContent(nInstances);

        if (classification) {
            int numClasses;
            keel.Dataset.Attribute a = keel.Dataset.Attributes.getOutputAttribute(0);
            if (a.getType() == keel.Dataset.Attribute.NOMINAL) {
                numClasses = a.getNumNominalValues();
            } else {
                numClasses = (int) (a.getMaxAttribute() - a.getMinAttribute());
            }
            Element nClasses = new Element("nClasses");
            nClasses.setText(Integer.toString(numClasses));
            root.addContent(nClasses);
        }

        if (userDatasetCheckBox.isSelected()) {
            Element userDataset = new Element("userDataset");
            root.addContent(field).addContent(userDataset);
        }


        data.getRootElement().addContent(root);

        try {
            File f = new File("./data/Datasets.xml");
            FileOutputStream file2 = new FileOutputStream(f);
            XMLOutputter fmt = new XMLOutputter();
            fmt.setFormat(Format.getPrettyFormat());
            fmt.output(data, file2);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        Attributes.clearAll();
        }
        //add new partitions to the existing ones
        else{
            Element partitions = new Element("partitions");
            Element partition;
            String newPartition="";
            
            if (partitionComboBox.getSelectedIndex() == 0) {         
                newPartition=trainingModel.size() + "cfv";
            } else if (partitionComboBox.getSelectedIndex() == 1) {
                newPartition="5x2cv";
            }
            
            List datasetsList = data.getRootElement().getChildren();
            Element aux, ourDataset = null;

            for (int i = 0; i < datasetsList.size(); i++) {
                aux=(Element)datasetsList.get(i);
                if(aux.getChildText("nameAbr").equals(lowerCaseName)){
                    ourDataset=aux;
                }
            }
            
            Vector partitionsVector = new Vector();
            Element temporal = ourDataset.getChild("partitions");

            for (int i = 0; i < temporal.getChildren().size(); i++) {
                partitionsVector.addElement(new String(((Element) (temporal.getChildren().get(i))).getText()));
            }
            
            boolean found=false;
            
            for (int i = 0; i < partitionsVector.size() && !found; i++) {
                if(partitionsVector.get(i).equals(newPartition)){
                    found=true;
                }
            }

            if(!found){
                partitionsVector.add(newPartition);
            }
            for (int i = 0; i < partitionsVector.size(); i++) {
                partition = new Element("partition");
                partition.setText((String)partitionsVector.get(i));
                partitions.addContent(partition);
            }

            Iterator it2 = data.getRootElement().getChildren().iterator();
            while (it2.hasNext()) {
                Element element = (Element) it2.next();
                if (element.getChild("nameAbr").getValue().equals(lowerCaseName)) {
                    element.removeChildren("partitions");
                    element.addContent(partitions);
                }
            }

            //check if the problem is unsupervised
            it2 = data.getRootElement().getChildren().iterator();
            while (it2.hasNext()) {
                Element element = (Element) it2.next();
                if (element.getChild("nameAbr").getValue().equals(lowerCaseName)) {
                    if(element.getChild("problemType").getValue().equals("Unsupervised")){
                        isUnsupervised=true;
                        JOptionPane.showMessageDialog(this, "All attributes have been automatically defined as inputs for this unsupervised data set problem.", "Attributes modified", JOptionPane.INFORMATION_MESSAGE);
                    }
                    else{
                        isUnsupervised=false;
                    }

                }
            }


            try {
                File f = new File("./data/Datasets.xml");
                FileOutputStream file2 = new FileOutputStream(f);
                XMLOutputter fmt = new XMLOutputter();
                fmt.setFormat(Format.getPrettyFormat());
                fmt.output(data, file2);
            }catch (Exception ex) {
                ex.printStackTrace();
            }
            Attributes.clearAll();
        }
        //return name in lowerCase
        return lowerCaseName;
    }
}

